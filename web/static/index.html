<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MAPA_FRENTES Web</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: "Segoe UI", Arial, sans-serif; background: #0a0a1a; color: #e0e0e0; }

    #toolbar {
      height: 44px; background: #16213e; display: flex;
      align-items: center; padding: 0 10px; gap: 8px;
      border-bottom: 2px solid #0f3460; flex-wrap: nowrap;
      overflow: visible; position: relative; z-index: 9500;
    }
    #toolbar label { color: #8899aa; font-size: 11px; white-space: nowrap; }
    #toolbar input, #toolbar select {
      padding: 4px 8px; border-radius: 3px; border: 1px solid #0f3460;
      background: #1a1a2e; color: #e0e0e0; font-size: 12px;
    }
    #toolbar button {
      padding: 5px 14px; border-radius: 4px; border: 1px solid #0f3460;
      background: #1a1a2e; color: #e0e0e0; cursor: pointer;
      font-size: 12px; white-space: nowrap; transition: background 0.2s;
    }
    #toolbar button:hover { background: #0f3460; }
    #toolbar button:disabled { opacity: 0.4; cursor: not-allowed; }
    #toolbar button.primary { background: #1a5276; border-color: #2980b9; }
    #toolbar button.primary:hover { background: #2980b9; }
    #toolbar button.danger { border-color: #c0392b; }
    #toolbar button.danger:hover { background: #c0392b; }
    .spacer { flex-grow: 1; }
    #status { color: #53a653; font-size: 11px; white-space: nowrap; max-width: 350px; overflow: hidden; text-overflow: ellipsis; }
    .tb-sep { width: 1px; height: 24px; background: #0f3460; flex-shrink: 0; }

    #front-type-swatch {
      display: inline-block; width: 14px; height: 14px;
      border-radius: 2px; vertical-align: middle; margin-left: 2px;
      border: 1px solid #555; background: #0033BB;
    }

    #mosaic {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      height: calc(100vh - 44px);
      gap: 2px; background: #0a0a1a;
    }
    .panel { position: relative; background: #1a1a2e; overflow: hidden; }
    .panel-field-select {
      position: absolute; top: 4px; left: 4px; z-index: 800;
      background: rgba(0,0,0,0.75); color: #fff; padding: 2px 6px;
      font-size: 11px; border-radius: 3px; border: 1px solid #0f3460;
      cursor: pointer; max-width: 160px;
    }
    .panel .leaflet-container { width: 100%; height: 100%; }
    .leaflet-container { background: #c8dff0 !important; }

    #loading {
      display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); z-index: 10000;
      justify-content: center; align-items: center;
    }
    #loading.active { display: flex; }
    #loading .spinner {
      width: 40px; height: 40px; border: 4px solid #333;
      border-top-color: #2980b9; border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #toolbar button.active-mode { background: #c0392b; border-color: #e74c3c; color: #fff; }

    .color-legend {
      position: absolute; bottom: 8px; left: 8px; z-index: 800;
      background: rgba(0,0,0,0.72); border-radius: 4px; padding: 4px 6px;
      font-size: 9px; color: #eee; pointer-events: none;
      max-width: 140px; line-height: 1.3;
    }
    .color-legend .cl-bar {
      width: 100%; height: 8px; border-radius: 2px; margin: 2px 0;
    }
    .color-legend .cl-labels {
      display: flex; justify-content: space-between; font-size: 8px;
    }
    .color-legend .cl-title {
      font-size: 9px; font-weight: 600; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }
    .precip-legend {
      position: absolute; bottom: 8px; right: 8px; z-index: 800;
      background: rgba(0,0,0,0.72); border-radius: 4px; padding: 4px 6px;
      font-size: 9px; color: #eee; pointer-events: none;
      max-width: 140px; line-height: 1.3;
    }
    .precip-legend .cl-bar {
      width: 100%; height: 8px; border-radius: 2px; margin: 2px 0;
    }
    .precip-legend .cl-labels {
      display: flex; justify-content: space-between; font-size: 8px;
    }
    .precip-legend .cl-title {
      font-size: 9px; font-weight: 600; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }

    /* Split vertex marker: scissors icon */
    .split-marker {
      width: 14px; height: 14px; border-radius: 50%;
      background: #ff4444; border: 2px solid #fff;
      cursor: crosshair; box-shadow: 0 0 4px rgba(255,0,0,0.6);
    }
    .split-marker:hover { background: #ff0; border-color: #000; transform: scale(1.3); }

    /* Edit dropdown menu items with active indicator */
    .export-dropdown-menu button.menu-active {
      background: #1a5276; color: #fff; font-weight: 600;
    }
    .export-dropdown-menu button.menu-active::before {
      content: "\2713 "; /* checkmark */
    }

    /* WMO symbol markers: no shadow, no default icon styles, allow rotation overflow */
    .wmo-symbol { background: none !important; border: none !important; overflow: visible !important; }

    /* Export dropdown */
    .export-dropdown {
      position: relative; display: inline-block;
    }
    .export-dropdown-btn {
      padding: 5px 14px; border-radius: 4px; border: 1px solid #0f3460;
      background: #1a1a2e; color: #e0e0e0; cursor: pointer;
      font-size: 12px; white-space: nowrap; transition: background 0.2s;
    }
    .export-dropdown-btn:hover { background: #0f3460; }
    .export-dropdown-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .export-dropdown-menu {
      display: none; position: absolute; top: 100%; left: 0;
      background: #16213e; border: 1px solid #0f3460; border-radius: 4px;
      z-index: 9000; min-width: 200px; margin-top: 2px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    .export-dropdown-menu.open { display: block; }
    .export-dropdown-menu button {
      display: block; width: 100%; text-align: left;
      padding: 8px 14px; border: none; background: none;
      color: #e0e0e0; font-size: 12px; cursor: pointer;
      white-space: nowrap;
    }
    .export-dropdown-menu button:hover { background: #0f3460; }
    .export-dropdown-menu hr {
      border: none; border-top: 1px solid #0f3460; margin: 2px 0;
    }

    /* Vertex edit markers */
    .vertex-marker {
      width: 12px; height: 12px; border-radius: 50%;
      background: #fff; border: 2px solid #222;
      cursor: grab; box-shadow: 0 0 3px rgba(0,0,0,0.4);
    }
    .vertex-marker:hover { background: #ff0; border-color: #000; }
    .vertex-marker:active { cursor: grabbing; }
  </style>
</head>
<body>

<div id="toolbar">
  <label>Fecha:</label>
  <input type="text" id="date-input" placeholder="YYYYMMDDHH" size="11" title="Ej: 2026021400. Vacio = ultimo disponible" />
  <label>Step:</label>
  <select id="step-select">
    <option value="0" selected>T+000</option>
    <option value="6">T+006</option>
    <option value="12">T+012</option>
    <option value="24">T+024</option>
    <option value="48">T+048</option>
    <option value="72">T+072</option>
  </select>
  <label>Layout:</label>
  <select id="layout-select">
    <option value="1x1">1 mapa</option>
    <option value="2x2" selected>2x2</option>
    <option value="3x2">3x2</option>
    <option value="3x3">3x3</option>
    <option value="4x3">4x3</option>
  </select>
  <button id="btn-load" class="primary">Cargar datos</button>
  <button id="btn-detect" disabled>Detectar frentes</button>

  <div class="tb-sep"></div>
  <label>Tipo frente:</label>
  <select id="front-type-select">
    <option value="cold">Frio</option>
    <option value="warm">Calido</option>
    <option value="occluded">Ocluido</option>
    <option value="stationary">Estacionario</option>
    <option value="instability_line">Lin. inestabilidad</option>
  </select>
  <span id="front-type-swatch"></span>
  <div class="tb-sep"></div>

  <button id="btn-save" disabled>Guardar</button>
  <div class="export-dropdown">
    <button class="export-dropdown-btn" id="btn-export-toggle" disabled>Exportar &#9662;</button>
    <div class="export-dropdown-menu" id="export-menu">
      <button id="btn-export">Con campo de fondo</button>
      <button id="btn-export-clean">Sin campo (limpio)</button>
      <hr/>
      <button id="btn-export-mosaic">Mosaico completo</button>
    </div>
  </div>
  <div class="tb-sep"></div>
  <label><input type="checkbox" id="precip-check" /> Precip</label>
  <label><input type="checkbox" id="wind-850-check" /> V850</label>
  <label><input type="checkbox" id="wind-700-check" /> V700</label>
  <div class="tb-sep"></div>
  <div class="export-dropdown">
    <button class="export-dropdown-btn" id="btn-edit-toggle" disabled>Edicion &#9662;</button>
    <div class="export-dropdown-menu" id="edit-menu">
      <button id="btn-edit-mode">Editar vertices</button>
      <button id="btn-split-mode">Dividir en vertice</button>
      <button id="btn-delete-mode">Borrar (click)</button>
      <hr/>
      <button id="btn-select-mode">Seleccionar</button>
      <button id="btn-select-rect">Seleccionar por area</button>
      <hr/>
      <button id="btn-assign-type">Asignar tipo a seleccion</button>
      <button id="btn-delete-selected" class="danger">Borrar seleccion</button>
      <hr/>
      <button id="btn-flip">Invertir todos los simbolos</button>
      <hr/>
      <button id="btn-center-delete">Borrar centro (A/B)</button>
      <button id="btn-center-add">Anadir centro (A/B)</button>
      <hr/>
      <button id="btn-undo">Deshacer (Ctrl+Z)</button>
    </div>
  </div>
  <span id="sel-count" style="color:#FFD700;font-size:11px;"></span>
  <span id="mode-indicator" style="font-size:11px;color:#e74c3c;"></span>
  <div class="spacer"></div>
  <span id="date-display" style="color:#FFD700;font-size:13px;font-weight:bold;padding:0 12px;white-space:nowrap;"></span>
  <span id="status">Listo</span>
</div>

<div id="mosaic"></div>
<div id="loading"><div class="spinner"></div></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
// ==========================================================================
// WMO Front Symbols - Direct SVG markers (no polylineDecorator dependency)
// ==========================================================================

/**
 * Compute evenly-spaced sample points along a polyline in pixel space.
 * Returns array of { latlng, angleDeg } where angleDeg is the line direction.
 */
function samplePointsAlongLine(latlngs, spacingPx, map) {
  if (!latlngs || latlngs.length < 2 || !map) return [];

  // Convert to pixel coords
  var pts = latlngs.map(function(ll) { return map.latLngToContainerPoint(ll); });

  // Compute cumulative pixel distance
  var cumDist = [0];
  for (var i = 1; i < pts.length; i++) {
    var dx = pts[i].x - pts[i-1].x;
    var dy = pts[i].y - pts[i-1].y;
    cumDist.push(cumDist[i-1] + Math.sqrt(dx*dx + dy*dy));
  }
  var totalLen = cumDist[cumDist.length - 1];
  if (totalLen < spacingPx * 0.5) return [];

  // Sample at even intervals starting at spacingPx/2
  var samples = [];
  var offset = spacingPx * 0.4;  // first symbol offset
  var segIdx = 0;

  for (var d = offset; d < totalLen - spacingPx * 0.3; d += spacingPx) {
    // Find segment containing distance d
    while (segIdx < cumDist.length - 2 && cumDist[segIdx + 1] < d) segIdx++;

    var segLen = cumDist[segIdx + 1] - cumDist[segIdx];
    if (segLen < 0.01) continue;
    var t = (d - cumDist[segIdx]) / segLen;

    // Interpolate position
    var px = pts[segIdx].x + t * (pts[segIdx + 1].x - pts[segIdx].x);
    var py = pts[segIdx].y + t * (pts[segIdx + 1].y - pts[segIdx].y);

    // Direction angle (degrees, 0 = right, CW positive for CSS transform)
    var dx2 = pts[segIdx + 1].x - pts[segIdx].x;
    var dy2 = pts[segIdx + 1].y - pts[segIdx].y;
    var angleDeg = Math.atan2(dy2, dx2) * 180 / Math.PI;

    var ll = map.containerPointToLatLng(L.point(px, py));
    samples.push({ latlng: ll, angleDeg: angleDeg });
  }

  return samples;
}

/**
 * Helper: rotate point (x,y) around origin by angle in radians.
 */
function _rot(x, y, cos_a, sin_a) {
  return [x * cos_a - y * sin_a, x * sin_a + y * cos_a];
}

/**
 * Create pre-rotated triangle SVG (no CSS transform needed).
 * Returns { html, size } where the SVG is a square of side `size`,
 * symbol centered, already rotated to `angleDeg`.
 * The anchor point is always the center of the SVG = point on the front line.
 *
 * angleDeg: direction the apex should point (screen coords, 0=right, CW positive).
 * h: height of triangle (apex distance from base center).
 */
function makeTriangleSVG(h, color, angleDeg) {
  var hw = h * 0.4;  // half base width
  var s = Math.ceil(h * 2) + 4;  // square SVG side
  var c = s / 2;  // center

  // Unrotated: base at origin, apex pointing UP (angle = -90 deg screen)
  // Vertices relative to base center (0,0):
  var verts = [[-hw, 0], [0, -h], [hw, 0]];

  // We want apex to point at angleDeg. Unrotated apex points at -90.
  // Rotation needed: angleDeg - (-90) = angleDeg + 90
  var rad = (angleDeg + 90) * Math.PI / 180;
  var cos_a = Math.cos(rad), sin_a = Math.sin(rad);

  var pts = verts.map(function(v) {
    var r = _rot(v[0], v[1], cos_a, sin_a);
    return (c + r[0]).toFixed(1) + ',' + (c + r[1]).toFixed(1);
  });

  return {
    html: '<svg width="' + s + '" height="' + s + '" viewBox="0 0 ' + s + ' ' + s + '" xmlns="http://www.w3.org/2000/svg">' +
      '<polygon points="' + pts.join(' ') + '" fill="' + color + '" stroke="' + color + '" stroke-width="0.5"/></svg>',
    size: s,
  };
}

/**
 * Create pre-rotated semicircle SVG (no CSS transform needed).
 * Returns { html, size }.
 *
 * angleDeg: direction the bulge should point (screen coords).
 * r: radius of semicircle.
 */
function makeSemicircleSVG(r, color, angleDeg) {
  if (r < 2) r = 2;
  var s = Math.ceil(r * 2) + 4;  // square SVG side
  var c = s / 2;  // center

  // Unrotated: flat edge horizontal at origin, bulge pointing UP (-90 deg)
  // Points relative to center of flat edge (0,0):
  var nSeg = 14;
  var verts = [];
  for (var i = 0; i <= nSeg; i++) {
    var t = Math.PI * i / nSeg;  // 0 to PI
    verts.push([-r * Math.cos(t), -r * Math.sin(t)]);  // bulges UP (negative Y)
  }

  // Rotate so bulge points at angleDeg (same logic as triangle)
  var rad = (angleDeg + 90) * Math.PI / 180;
  var cos_a = Math.cos(rad), sin_a = Math.sin(rad);

  var pts = verts.map(function(v) {
    var rv = _rot(v[0], v[1], cos_a, sin_a);
    return (c + rv[0]).toFixed(1) + ',' + (c + rv[1]).toFixed(1);
  });

  return {
    html: '<svg width="' + s + '" height="' + s + '" viewBox="0 0 ' + s + ' ' + s + '" xmlns="http://www.w3.org/2000/svg">' +
      '<polygon points="' + pts.join(' ') + '" fill="' + color + '" stroke="' + color + '" stroke-width="0.5"/></svg>',
    size: s,
  };
}

/**
 * Place WMO symbol markers along a polyline.
 * Symbols are pre-rotated SVGs centered on the line point (no CSS transform).
 *
 * symbolType: "triangle", "semicircle", "both" (occluded), "stationary"
 * opts.flip: if true, symbols point to the opposite side
 */
function createWMOSymbolMarkers(latlngs, map, symbolType, color, opts) {
  opts = opts || {};
  var zoom = map.getZoom();
  var triH     = (zoom >= 7) ? 18 : (zoom >= 5 ? 14 : 10);
  var semiR    = (zoom >= 7) ? 9  : (zoom >= 5 ? 7  : 5);
  var spacing  = (zoom >= 7) ? 50 : (zoom >= 5 ? 40 : 30);
  var flip = opts.flip || false;

  var samples = samplePointsAlongLine(latlngs, spacing, map);
  var markers = [];

  samples.forEach(function(sample, idx) {
    // Direction perpendicular to line, pointing RIGHT of line direction
    var perpAngle = sample.angleDeg + 90;
    if (flip) perpAngle += 180;

    var sym, symSize;

    if (symbolType === "triangle") {
      sym = makeTriangleSVG(triH, color, perpAngle);

    } else if (symbolType === "semicircle") {
      sym = makeSemicircleSVG(semiR, color, perpAngle);

    } else if (symbolType === "both") {
      // Occluded: alternate triangle and semicircle
      if (idx % 2 === 0) {
        sym = makeTriangleSVG(triH, color, perpAngle);
      } else {
        sym = makeSemicircleSVG(semiR, color, perpAngle);
      }

    } else if (symbolType === "stationary") {
      // Blue triangles on one side, red semicircles on the opposite
      if (idx % 2 === 0) {
        sym = makeTriangleSVG(triH, "#0033BB", perpAngle);
      } else {
        sym = makeSemicircleSVG(semiR, "#CC0000", perpAngle + 180);
      }

    } else {
      return;
    }

    symSize = sym.size;
    var half = symSize / 2;

    var icon = L.divIcon({
      className: "wmo-symbol",
      html: sym.html,
      iconSize: [symSize, symSize],
      iconAnchor: [half, half],  // center of SVG = point on line
    });

    markers.push(L.marker(sample.latlng, {
      icon: icon,
      interactive: false,
      pane: "fronts",
    }));
  });

  return markers;
}

// ==========================================================================
// Config
// ==========================================================================
var DEFAULT_FIELDS = [
  "theta_e_850", "grad_theta_e_850", "temp_advection_850",
  "wind_speed_850", "vorticity_850", "thickness_1000_500",
  "theta_e_700", "grad_t_850", "wind_speed_500",
  "temp_850", "humidity_850", "theta_e_850",
];

var FRONT_COLORS = {
  cold: "#0033BB", warm: "#CC0000", occluded: "#8800AA",
  cold_occluded: "#6600CC", warm_occluded: "#AA0088",
  warm_seclusion: "#DD0066", stationary: "#006600",
  instability_line: "#CC4400",
};

var DEFAULT_CENTER = [45, -15];
var DEFAULT_ZOOM = 4;

// ==========================================================================
// State
// ==========================================================================
var maps = [];
var fieldOverlays = [];
var precipOverlays = []; // precipitation PNG overlays per panel
var windLayers = [];     // wind vector canvas layers per panel
var isobarLayers = [];
var centerLayers = [];
var coastlineLayers = [];
var frontLayers = [];
var drawControls = [];

var dataBounds = null;
var dataLoaded = false;
var availableFields = null;
var coastlineData = null;
var masterFronts = { type: "FeatureCollection", features: [] };
var deleteMode = false;
var editMode = false;
var splitMode = false;
var selectMode = false;
var selectedFronts = new Set();   // Set of feature indices selected
var selectRectDrawer = null;      // L.Draw.Rectangle handler
var selectedFeature = null;
var vertexMarkers = [];       // L.marker arrastrables (solo panel 0)
var editHighlights = [];      // L.polyline resaltadas (todos los paneles)
var colorLegends = [];  // DOM elements per panel
var undoStack = [];     // snapshots of masterFronts for undo
var UNDO_MAX = 30;      // max undo levels

// ==========================================================================
// Undo
// ==========================================================================
function pushUndo() {
  // Deep-copy current masterFronts
  undoStack.push(JSON.stringify(masterFronts));
  if (undoStack.length > UNDO_MAX) undoStack.shift();
}

function undoAction() {
  if (undoStack.length === 0) {
    setStatus("Nada que deshacer");
    return;
  }
  masterFronts = JSON.parse(undoStack.pop());
  selectedFronts.clear();
  updateSelectionUI();
  clearEditSelection();
  renderFrontsOnAllPanels();
  setStatus("Deshacer (" + undoStack.length + " niveles restantes)");
}

// ==========================================================================
// UI helpers
// ==========================================================================
function setStatus(msg) { document.getElementById("status").textContent = msg; }
function showLoading() { document.getElementById("loading").classList.add("active"); }
function hideLoading() { document.getElementById("loading").classList.remove("active"); }
function setButtonsEnabled(loaded) {
  document.getElementById("btn-detect").disabled = !loaded;
  document.getElementById("btn-save").disabled = !loaded;
  document.getElementById("btn-export-toggle").disabled = !loaded;
  document.getElementById("btn-flip").disabled = !loaded;
  document.getElementById("btn-edit-toggle").disabled = !loaded;
}

function getSelectedFrontType() {
  return document.getElementById("front-type-select").value;
}
function getSelectedFrontColor() {
  return FRONT_COLORS[getSelectedFrontType()] || "#0033BB";
}

// ==========================================================================
// Front rendering
// ==========================================================================
function frontLineStyle(frontType) {
  var color = FRONT_COLORS[frontType] || "#0033BB";
  var dashArray = frontType === "instability_line" ? "8 4 2 4" : null;
  return { color: color, weight: 3, opacity: 0.9, dashArray: dashArray, pane: "fronts" };
}

/**
 * Determine WMO symbol type and color for a given front type.
 */
function getSymbolConfig(frontType) {
  switch (frontType) {
    case "cold":
    case "cold_occluded":
      return { symbolType: "triangle", color: FRONT_COLORS[frontType] };
    case "warm":
    case "warm_occluded":
    case "warm_seclusion":
      return { symbolType: "semicircle", color: FRONT_COLORS[frontType] };
    case "occluded":
      return { symbolType: "both", color: FRONT_COLORS.occluded };
    case "stationary":
      return { symbolType: "stationary", color: "#006600" };
    default:
      return null;  // instability_line: no symbols
  }
}

function renderFrontsOnAllPanels() {
  maps.forEach(function(map, i) {
    if (frontLayers[i]) {
      map.removeLayer(frontLayers[i]);
      frontLayers[i] = null;
    }

    var group = L.layerGroup().addTo(map);

    (masterFronts.features || []).forEach(function(feature, featureIdx) {
      var coords = feature.geometry && feature.geometry.coordinates;
      if (!coords || coords.length < 2) return;

      var latlngs = coords.map(function(c) { return L.latLng(c[1], c[0]); });
      var ft = (feature.properties && feature.properties.front_type) || "cold";

      // Selection highlight (gold outline behind the front)
      if (selectedFronts.has(featureIdx)) {
        L.polyline(latlngs, {
          color: "#FFD700", weight: 7, opacity: 0.6, interactive: false, pane: "fronts"
        }).addTo(group);
      }

      // Draw the line
      var line = L.polyline(latlngs, frontLineStyle(ft)).addTo(group);

      // Click behavior depends on mode
      line.on("click", function(e) {
        L.DomEvent.stopPropagation(e);
        if (splitMode) {
          // Select front for splitting
          selectFrontForSplit(feature);
        } else if (selectMode) {
          // Toggle selection
          if (selectedFronts.has(featureIdx)) {
            selectedFronts.delete(featureIdx);
          } else {
            selectedFronts.add(featureIdx);
          }
          updateSelectionUI();
          renderFrontsOnAllPanels();
        } else if (deleteMode) {
          // Delete this front
          pushUndo();
          var idx = masterFronts.features.indexOf(feature);
          if (idx >= 0) masterFronts.features.splice(idx, 1);
          renderFrontsOnAllPanels();
          setStatus("Frente eliminado");
        } else if (editMode) {
          // Select front for vertex editing
          selectFrontForEdit(feature);
        } else {
          // Flip symbol direction
          pushUndo();
          feature.properties.flip = !feature.properties.flip;
          feature.properties.flip_symbols = feature.properties.flip;
          renderFrontsOnAllPanels();
          setStatus("Simbolos invertidos (" + ft + ")");
        }
      });

      // WMO symbols as div markers
      var symCfg = getSymbolConfig(ft);
      if (symCfg) {
        var isFlipped = !!(feature.properties && feature.properties.flip);
        var markers = createWMOSymbolMarkers(latlngs, map, symCfg.symbolType, symCfg.color, { flip: isFlipped });
        markers.forEach(function(m) { m.addTo(group); });
      }
    });

    frontLayers[i] = group;
  });
}

// ==========================================================================
// Coastlines
// ==========================================================================
async function loadCoastlines() {
  if (coastlineData) return coastlineData;
  try {
    var resp = await fetch("/api/coastlines");
    coastlineData = await resp.json();
  } catch (e) {
    console.warn("No se pudieron cargar costas:", e);
    coastlineData = { type: "FeatureCollection", features: [] };
  }
  return coastlineData;
}

function addCoastlineToMap(map, idx) {
  if (!coastlineData) return;
  if (coastlineLayers[idx]) map.removeLayer(coastlineLayers[idx]);
  coastlineLayers[idx] = L.geoJSON(coastlineData, {
    pane: "coastlines",
    style: function(feature) {
      return {
        color: feature.properties.layer === "coastline" ? "#222" : "#777",
        weight: feature.properties.layer === "coastline" ? 1.3 : 0.5,
        opacity: 0.9,
        interactive: false,
      };
    },
  }).addTo(map);
}

// ==========================================================================
// Build / Rebuild mosaic
// ==========================================================================
function parseLayout() {
  var val = document.getElementById("layout-select").value;
  var parts = val.split("x").map(Number);
  return { cols: parts[0], rows: parts[1] };
}

function _createPanel(idx, mosaic, fieldKeys, fieldLabels) {
  var panel = document.createElement("div");
  panel.className = "panel";

  var sel = document.createElement("select");
  sel.className = "panel-field-select";
  sel.dataset.panelIdx = idx;

  // Opcion "Sin fondo" (mapa limpio)
  var noneOpt = document.createElement("option");
  noneOpt.value = "none";
  noneOpt.textContent = "Sin fondo";
  sel.appendChild(noneOpt);

  if (fieldKeys.length > 0) {
    fieldKeys.forEach(function(key) {
      var opt = document.createElement("option");
      opt.value = key;
      opt.textContent = fieldLabels[key] || key;
      sel.appendChild(opt);
    });
    var defField = DEFAULT_FIELDS[idx % DEFAULT_FIELDS.length];
    sel.value = fieldKeys.indexOf(defField) >= 0 ? defField : fieldKeys[idx % fieldKeys.length];
  } else {
    var opt = document.createElement("option");
    opt.value = DEFAULT_FIELDS[idx % DEFAULT_FIELDS.length];
    opt.textContent = opt.value;
    sel.appendChild(opt);
  }
  sel.addEventListener("change", function() { onPanelFieldChange(idx); });
  panel.appendChild(sel);

  var mapDiv = document.createElement("div");
  mapDiv.id = "map-" + idx;
  mapDiv.style.cssText = "width:100%;height:100%";
  panel.appendChild(mapDiv);
  mosaic.appendChild(panel);

  var map = L.map("map-" + idx, {
    center: DEFAULT_CENTER,
    zoom: DEFAULT_ZOOM,
    zoomControl: (idx === 0),
    attributionControl: false,
  });

  // Custom panes
  map.createPane("coastlines");
  map.getPane("coastlines").style.zIndex = 450;
  map.createPane("fronts");
  map.getPane("fronts").style.zIndex = 650;
  map.createPane("vertexEdit");
  map.getPane("vertexEdit").style.zIndex = 700;

  // Basemap
  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
    { opacity: 0.4, maxZoom: 12 }
  ).addTo(map);

  addCoastlineToMap(map, idx);

  fieldOverlays.push(null);
  precipOverlays.push(null);
  windLayers.push(null);
  isobarLayers.push(null);
  centerLayers.push(null);
  frontLayers.push(null);

  // Sync zoom/pan
  map.on("moveend", function() { syncMaps(idx); });

  // Re-render fronts on zoom (symbol sizes depend on zoom)
  // and refresh field images/legends to rescale colors to viewport
  var _zoomRenderTimeout = null;
  map.on("zoomend", function() {
    if (_zoomRenderTimeout) clearTimeout(_zoomRenderTimeout);
    _zoomRenderTimeout = setTimeout(function() {
      renderFrontsOnAllPanels();
    }, 300);
  });
  // Reescalar leyendas (campo + precipitacion) al hacer zoom o pan
  var _viewportRefreshTimeout = null;
  map.on("moveend", function() {
    if (_viewportRefreshTimeout) clearTimeout(_viewportRefreshTimeout);
    _viewportRefreshTimeout = setTimeout(function() {
      if (dataLoaded) refreshFieldsForViewport();
    }, 500);
  });

  // Click on map background: deselect in any mode
  map.on("click", function() {
    if (selectMode && selectedFronts.size > 0) {
      selectedFronts.clear();
      updateSelectionUI();
      renderFrontsOnAllPanels();
      setStatus("Seleccion limpiada. Click en frentes para seleccionar.");
    } else if ((editMode || splitMode) && selectedFeature) {
      clearEditSelection();
      setStatus("Frente deseleccionado.");
    }
  });

  maps.push(map);
  initDrawOnPanel(idx);
}

function rebuildMosaic(cols, rows) {
  maps.forEach(function(m) { m.remove(); });
  maps = [];
  fieldOverlays = [];
  precipOverlays = [];
  windLayers = [];
  isobarLayers = [];
  centerLayers = [];
  coastlineLayers = [];
  frontLayers = [];
  drawControls = [];
  colorLegends = [];

  var mosaic = document.getElementById("mosaic");
  mosaic.innerHTML = "";
  mosaic.style.gridTemplateColumns = "repeat(" + cols + ", 1fr)";
  mosaic.style.gridTemplateRows = "repeat(" + rows + ", 1fr)";

  var nPanels = cols * rows;
  var fieldKeys = availableFields ? Object.keys(availableFields) : [];
  var fieldLabels = availableFields || {};

  for (var i = 0; i < nPanels; i++) {
    _createPanel(i, mosaic, fieldKeys, fieldLabels);
  }

  if (dataLoaded) {
    loadFieldImages();
    loadIsobars();
    loadCenters();
    renderFrontsOnAllPanels();
  }
}

function _getDrawShapeOptions() {
  var ft = getSelectedFrontType();
  var color = getSelectedFrontColor();
  var dashArray = ft === "instability_line" ? "8 4 2 4" :
                  ft === "stationary" ? "6 3" : null;
  return { color: color, weight: 3, opacity: 0.9, dashArray: dashArray };
}

function _createDrawControl(shapeOptions) {
  return new L.Control.Draw({
    position: "topright",
    edit: false,
    draw: {
      polyline: { shapeOptions: shapeOptions },
      polygon: false, rectangle: false,
      circle: false, marker: false, circlemarker: false,
    },
  });
}

function initDrawOnPanel(panelIdx) {
  var dc = _createDrawControl(_getDrawShapeOptions());
  maps[panelIdx].addControl(dc);
  drawControls[panelIdx] = dc;

  maps[panelIdx].on(L.Draw.Event.CREATED, function(e) {
    var layer = e.layer;

    // Rectangle selection mode: select fronts inside rectangle
    if (selectMode && e.layerType === "rectangle") {
      handleRectangleCreated(e);
      return;
    }

    // Normal draw: create a new front
    var selectedType = getSelectedFrontType();
    var geojson = layer.toGeoJSON();

    var feature = {
      type: "Feature",
      properties: {
        front_type: selectedType,
        id: "new_" + Date.now() + "_" + Math.random().toString(36).substr(2, 4)
      },
      geometry: geojson.geometry,
    };

    pushUndo();
    masterFronts.features.push(feature);
    renderFrontsOnAllPanels();
    setStatus("Frente " + selectedType + " dibujado");
  });
}

function updateAllDrawOptions() {
  document.getElementById("front-type-swatch").style.background = getSelectedFrontColor();
  var shapeOptions = _getDrawShapeOptions();

  maps.forEach(function(map, i) {
    if (drawControls[i]) map.removeControl(drawControls[i]);
    var dc = _createDrawControl(shapeOptions);
    map.addControl(dc);
    drawControls[i] = dc;
  });
}

function onPanelFieldChange(panelIdx) {
  if (!dataLoaded || !dataBounds) return;
  var sel = document.querySelector('.panel-field-select[data-panel-idx="' + panelIdx + '"]');
  if (!sel) return;
  loadSingleFieldImage(panelIdx, sel.value);
}

function _getViewportParams(map) {
  var b = map.getBounds();
  return "south=" + b.getSouth().toFixed(2) +
    "&north=" + b.getNorth().toFixed(2) +
    "&west=" + b.getWest().toFixed(2) +
    "&east=" + b.getEast().toFixed(2);
}

// Matplotlib colormaps approximated as CSS gradients (key subset)
var CMAP_CSS = {
  RdYlBu_r: "linear-gradient(to right, #313695, #4575b4, #74add1, #abd9e9, #e0f3f8, #ffffbf, #fee090, #fdae61, #f46d43, #d73027, #a50026)",
  coolwarm: "linear-gradient(to right, #3b4cc0, #6788ee, #9abbff, #c9d7ef, #edd1c2, #f7a889, #e26952, #b40426)",
  RdBu_r: "linear-gradient(to right, #053061, #2166ac, #4393c3, #92c5de, #d1e5f0, #f7f7f7, #fddbc7, #f4a582, #d6604d, #b2182b, #67001f)",
  YlOrRd: "linear-gradient(to right, #ffffcc, #ffeda0, #fed976, #feb24c, #fd8d3c, #fc4e2a, #e31a1c, #b10026)",
  viridis: "linear-gradient(to right, #440154, #482777, #3e4989, #31688e, #26828e, #1f9e89, #35b779, #6ece58, #b5de2b, #fde725)",
  BrBG: "linear-gradient(to right, #543005, #8c510a, #bf812d, #dfc27d, #f6e8c3, #f5f5f5, #c7eae5, #80cdc1, #35978f, #01665e, #003c30)",
  hot_r: "linear-gradient(to right, #ffffff, #ffff00, #ff8800, #ff0000, #880000, #000000)",
  Blues: "linear-gradient(to right, #f7fbff, #deebf7, #c6dbef, #9ecae1, #6baed6, #4292c6, #2171b5, #084594)",
  YlGnBu: "linear-gradient(to right, #ffffd9, #edf8b1, #c7e9b4, #7fcdbb, #41b6c4, #1d91c0, #225ea8, #0c2c84)",
  bwr: "linear-gradient(to right, #0000ff, #4444ff, #8888ff, #ccccff, #ffffff, #ffcccc, #ff8888, #ff4444, #ff0000)",
  PiYG_r: "linear-gradient(to right, #276419, #4d9221, #7fbc41, #b8e186, #e6f5d0, #f7f7f7, #fde0ef, #f1b6da, #de77ae, #c51b7d, #8e0152)",
};

function _cmapToCSS(cmapName) {
  return CMAP_CSS[cmapName] || CMAP_CSS.viridis;
}

function _formatValue(v) {
  var abs = Math.abs(v);
  if (abs === 0) return "0";
  if (abs >= 1000) return v.toFixed(0);
  if (abs >= 10) return v.toFixed(1);
  if (abs >= 0.1) return v.toFixed(2);
  return v.toExponential(1);
}

function updateColorLegend(panelIdx, info) {
  var panel = document.querySelectorAll(".panel")[panelIdx];
  if (!panel) return;

  // Remove existing legend
  var existing = panel.querySelector(".color-legend");
  if (existing) existing.remove();

  if (!info) return;

  var div = document.createElement("div");
  div.className = "color-legend";
  div.innerHTML =
    '<div class="cl-title">' + info.label + ' (' + info.units + ')</div>' +
    '<div class="cl-bar" style="background:' + _cmapToCSS(info.cmap) + '"></div>' +
    '<div class="cl-labels"><span>' + _formatValue(info.vmin) + '</span><span>' + _formatValue(info.vmax) + '</span></div>';
  panel.appendChild(div);
}

async function loadSingleFieldImage(idx, fieldName) {
  var map = maps[idx];

  // Si es "none", quitar overlay y leyenda
  if (fieldName === "none") {
    if (fieldOverlays[idx]) { map.removeLayer(fieldOverlays[idx]); fieldOverlays[idx] = null; }
    updateColorLegend(idx, null);
    return;
  }

  var vp = _getViewportParams(map);
  var timestamp = Date.now();
  var url = "/api/fields/" + fieldName + "/image?" + vp + "&t=" + timestamp;
  if (fieldOverlays[idx]) map.removeLayer(fieldOverlays[idx]);
  var overlay = L.imageOverlay(url, dataBounds, {
    opacity: 0.65, interactive: false, zIndex: 100,
  });
  overlay.addTo(map);
  fieldOverlays[idx] = overlay;

  // Fetch colorbar info
  try {
    var cbResp = await fetch("/api/fields/" + fieldName + "/colorbar?" + vp);
    if (cbResp.ok) {
      var cbInfo = await cbResp.json();
      updateColorLegend(idx, cbInfo);
    }
  } catch (e) { /* ignore */ }
}

async function loadPrecipOverlay() {
  if (!dataLoaded || !dataBounds) return;
  // Remove existing overlays and legends
  for (var i = 0; i < maps.length; i++) {
    if (precipOverlays[i]) { maps[i].removeLayer(precipOverlays[i]); precipOverlays[i] = null; }
  }
  _removePrecipLegends();

  if (!document.getElementById("precip-check").checked) return;

  // Verificar si hay datos de precipitacion
  try {
    var statusResp = await fetch("/api/precipitation/status");
    var statusData = await statusResp.json();
    if (!statusData.available) {
      setStatus("Precip: " + statusData.reason);
      document.getElementById("precip-check").checked = false;
      return;
    }
  } catch (e) { /* continuar igualmente */ }

  var timestamp = Date.now();
  var url = "/api/precipitation/image?t=" + timestamp;
  for (var i = 0; i < maps.length; i++) {
    var overlay = L.imageOverlay(url, dataBounds, {
      opacity: 0.7, interactive: false, zIndex: 150,
    });
    overlay.addTo(maps[i]);
    precipOverlays[i] = overlay;
  }

  // Fetch precipitation colorbar info (uses viewport)
  try {
    var vp = maps.length > 0 ? _getViewportParams(maps[0]) : "";
    var cbResp = await fetch("/api/precipitation/colorbar?" + vp);
    if (cbResp.ok) {
      var cbInfo = await cbResp.json();
      _updatePrecipLegends(cbInfo);
    }
  } catch (e) { /* ignore */ }

  setStatus("Precipitacion activada");
}

function _updatePrecipLegends(info) {
  _removePrecipLegends();
  var panels = document.querySelectorAll(".panel");
  for (var i = 0; i < panels.length; i++) {
    var div = document.createElement("div");
    div.className = "precip-legend";
    div.innerHTML =
      '<div class="cl-title">' + info.label + ' (' + info.units + ')</div>' +
      '<div class="cl-bar" style="background:' + _cmapToCSS(info.cmap) + '"></div>' +
      '<div class="cl-labels"><span>' + _formatValue(info.vmin) + '</span><span>' + _formatValue(info.vmax) + '</span></div>';
    panels[i].appendChild(div);
  }
}

function _removePrecipLegends() {
  var existing = document.querySelectorAll(".precip-legend");
  existing.forEach(function(el) { el.remove(); });
}

// --- Wind arrows canvas layer ---
// Dibuja flechas de viento directamente en canvas de Leaflet (no PNG).
// Se adaptan al zoom y siempre se ven nitidas.

var _windDataCache = {};  // cache por nivel: { 850: {lat,lon,u,v,color,alpha}, ... }

L.WindArrowsLayer = L.Layer.extend({
  initialize: function(data, options) {
    this._data = data;  // {lat[], lon[], u[], v[], color, alpha}
    L.Util.setOptions(this, options);
  },

  onAdd: function(map) {
    this._map = map;
    this._canvas = L.DomUtil.create("canvas", "wind-arrows-canvas");
    this._canvas.style.position = "absolute";
    this._canvas.style.pointerEvents = "none";
    this._canvas.style.zIndex = "200";
    map.getPane("overlayPane").appendChild(this._canvas);
    map.on("moveend zoomend resize", this._redraw, this);
    this._redraw();
  },

  onRemove: function(map) {
    map.off("moveend zoomend resize", this._redraw, this);
    L.DomUtil.remove(this._canvas);
  },

  _redraw: function() {
    var map = this._map;
    var size = map.getSize();
    var canvas = this._canvas;
    canvas.width = size.x;
    canvas.height = size.y;
    var topLeft = map.containerPointToLayerPoint([0, 0]);
    L.DomUtil.setPosition(canvas, topLeft);

    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, size.x, size.y);

    var d = this._data;
    if (!d || !d.lat || d.lat.length === 0) return;

    var bounds = map.getBounds();
    var zoom = map.getZoom();

    // Tamano de flecha en pixeles, adaptado al zoom
    var arrowLen = Math.max(8, Math.min(22, 4 + zoom * 2.5));
    var headLen = arrowLen * 0.35;
    var headHalf = headLen * 0.45;
    var lineWidth = Math.max(1, arrowLen / 12);

    ctx.strokeStyle = d.color || "#555555";
    ctx.fillStyle = d.color || "#555555";
    ctx.globalAlpha = d.alpha !== undefined ? d.alpha : 1.0;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = "round";

    for (var i = 0; i < d.lat.length; i++) {
      var lat = d.lat[i], lon = d.lon[i];

      // Solo dibujar si esta en el viewport
      if (lat < bounds.getSouth() || lat > bounds.getNorth()) continue;
      if (lon < bounds.getWest() || lon > bounds.getEast()) continue;

      var pt = map.latLngToContainerPoint([lat, lon]);
      var u = d.u[i], v = d.v[i];
      var speed = Math.sqrt(u * u + v * v);
      if (speed < 0.5) continue;  // no dibujar calma

      // Angulo: u=este, v=norte
      var angle = Math.atan2(-v, u);  // canvas Y invertido

      // Escalar longitud por velocidad (normalizado a ~40kt max)
      var lenScale = Math.min(speed / 40, 1.5);
      var len = arrowLen * lenScale;

      var dx = Math.cos(angle) * len;
      var dy = Math.sin(angle) * len;

      var x0 = pt.x - dx * 0.5;
      var y0 = pt.y - dy * 0.5;
      var x1 = pt.x + dx * 0.5;
      var y1 = pt.y + dy * 0.5;

      // Linea del cuerpo
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();

      // Punta de flecha
      var ha = Math.atan2(dy, dx);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(
        x1 - headLen * Math.cos(ha - 0.45),
        y1 - headLen * Math.sin(ha - 0.45)
      );
      ctx.lineTo(
        x1 - headLen * Math.cos(ha + 0.45),
        y1 - headLen * Math.sin(ha + 0.45)
      );
      ctx.closePath();
      ctx.fill();
    }
  },
});

function loadWindOverlays() {
  if (!dataLoaded) return;

  // Eliminar layers existentes
  for (var i = 0; i < maps.length; i++) {
    if (windLayers[i]) {
      windLayers[i].forEach(function(layer) { maps[i].removeLayer(layer); });
      windLayers[i] = null;
    }
  }

  var levels = [];
  if (document.getElementById("wind-850-check").checked) levels.push(850);
  if (document.getElementById("wind-700-check").checked) levels.push(700);
  if (levels.length === 0) return;

  // Cargar datos JSON para cada nivel y dibujar en canvas
  levels.forEach(function(level) {
    // Usar cache si existe
    if (_windDataCache[level]) {
      _addWindLayersForLevel(level, _windDataCache[level]);
      return;
    }

    fetch("/api/wind_vectors/" + level + "/data")
      .then(function(r) { return r.json(); })
      .then(function(data) {
        _windDataCache[level] = data;
        _addWindLayersForLevel(level, data);
      })
      .catch(function(e) {
        console.warn("Error cargando viento " + level + ":", e);
      });
  });
}

function _addWindLayersForLevel(level, data) {
  for (var i = 0; i < maps.length; i++) {
    var layer = new L.WindArrowsLayer(data);
    layer.addTo(maps[i]);
    if (!windLayers[i]) windLayers[i] = [];
    windLayers[i].push(layer);
  }
}

var _syncing = false;
function syncMaps(sourceIdx) {
  if (_syncing) return;
  _syncing = true;
  var center = maps[sourceIdx].getCenter();
  var zoom = maps[sourceIdx].getZoom();
  maps.forEach(function(m, i) {
    if (i !== sourceIdx) m.setView(center, zoom, { animate: false });
  });
  setTimeout(function() { _syncing = false; }, 150);
}

// ==========================================================================
// Load data
// ==========================================================================
async function loadData() {
  var dateStr = document.getElementById("date-input").value.trim() || null;
  var step = parseInt(document.getElementById("step-select").value);

  showLoading();
  setStatus("Descargando datos ECMWF...");

  try {
    var resp = await fetch("/api/load", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ date: dateStr, step: step }),
    });
    if (!resp.ok) {
      var err = await resp.json();
      throw new Error(err.detail || "Error cargando datos");
    }
    var data = await resp.json();

    var boundsResp = await fetch("/api/bounds");
    var boundsData = await boundsResp.json();
    var db = boundsData.data_bounds;
    dataBounds = [[db.south, db.west], [db.north, db.east]];

    if (boundsData.fields) {
      availableFields = boundsData.fields;
      updatePanelDropdowns();
    }

    setStatus("Generando capas...");

    await Promise.all([
      loadFieldImages(),
      loadIsobars(),
      loadCenters(),
    ]);

    dataLoaded = true;
    _windDataCache = {};  // invalidar cache de viento al recargar datos
    setButtonsEnabled(true);

    masterFronts = { type: "FeatureCollection", features: [] };
    renderFrontsOnAllPanels();

    var dateInfo = boundsData.date_info || "";
    var dateText = dateInfo ? dateInfo.replace("T", " ") + " UTC" : "";
    document.getElementById("date-display").textContent = dateText;
    setStatus("Datos cargados: " + data.n_centers + " centros.");
  } catch (e) {
    setStatus("Error: " + e.message);
    console.error(e);
  } finally {
    hideLoading();
  }
}

function updatePanelDropdowns() {
  if (!availableFields) return;
  var fieldKeys = Object.keys(availableFields);

  document.querySelectorAll(".panel-field-select").forEach(function(sel) {
    var currentVal = sel.value;
    var idx = parseInt(sel.dataset.panelIdx);
    sel.innerHTML = "";
    var noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "Sin fondo";
    sel.appendChild(noneOpt);
    fieldKeys.forEach(function(key) {
      var opt = document.createElement("option");
      opt.value = key;
      opt.textContent = availableFields[key];
      sel.appendChild(opt);
    });
    if (fieldKeys.includes(currentVal)) {
      sel.value = currentVal;
    } else {
      var def = DEFAULT_FIELDS[idx % DEFAULT_FIELDS.length];
      sel.value = fieldKeys.includes(def) ? def : fieldKeys[0];
    }
  });
}

// ==========================================================================
// Field images
// ==========================================================================
async function loadFieldImages() {
  var selectors = document.querySelectorAll(".panel-field-select");
  var promises = [];

  for (var i = 0; i < maps.length; i++) {
    var fieldName = selectors[i] ? selectors[i].value : DEFAULT_FIELDS[i % DEFAULT_FIELDS.length];
    promises.push(loadSingleFieldImage(i, fieldName));
  }
  await Promise.all(promises);
}

var _refreshFieldsTimeout = null;
function refreshFieldsForViewport() {
  if (_refreshFieldsTimeout) clearTimeout(_refreshFieldsTimeout);
  _refreshFieldsTimeout = setTimeout(async function() {
    loadFieldImages();
    // Reescalar leyenda de precipitacion si esta activa
    if (precipOverlays.some(function(o) { return o !== null; })) {
      try {
        var vp = maps.length > 0 ? _getViewportParams(maps[0]) : "";
        var cbResp = await fetch("/api/precipitation/colorbar?" + vp);
        if (cbResp.ok) {
          var cbInfo = await cbResp.json();
          _updatePrecipLegends(cbInfo);
        }
      } catch (e) { /* ignore */ }
    }
  }, 400);
}

// ==========================================================================
// Isobars
// ==========================================================================
async function loadIsobars() {
  var resp = await fetch("/api/isobars");
  var geojson = await resp.json();

  maps.forEach(function(map, i) {
    if (isobarLayers[i]) map.removeLayer(isobarLayers[i]);
    isobarLayers[i] = L.geoJSON(geojson, {
      style: function(feature) {
        return {
          color: "#444",
          weight: feature.properties.is_master ? 1.4 : 0.5,
          opacity: feature.properties.is_master ? 0.7 : 0.4,
          interactive: false,
        };
      },
    }).addTo(map);
  });
}

// ==========================================================================
// Pressure centers (editable client-side)
// ==========================================================================
var masterCenters = [];  // array of {id, type, lat, lon, value, primary, name, label}
var centerDeleteMode = false;

async function loadCenters() {
  var resp = await fetch("/api/centers");
  masterCenters = await resp.json();
  renderCentersOnAllPanels();
}

function renderCentersOnAllPanels() {
  maps.forEach(function(map, i) {
    if (centerLayers[i]) map.removeLayer(centerLayers[i]);

    var layer = L.layerGroup();
    masterCenters.forEach(function(c, cIdx) {
      var label = c.label || (c.type === "H" ? "A" : "B");
      var color = c.type === "H" ? "#0044CC" : "#CC0000";
      var size = label === label.toUpperCase() ? 16 : 12;
      var nameHtml = c.name ? '<br><span style="font-size:9px;font-style:italic">' + c.name + '</span>' : "";

      var icon = L.divIcon({
        className: "",
        html: '<div style="text-align:center;color:' + color + ';font-weight:bold;' +
          'font-size:' + size + 'px;text-shadow:0 0 3px white,0 0 3px white,0 0 5px white;' +
          'line-height:1.1;pointer-events:auto;cursor:pointer;">' +
          label + nameHtml + '<br>' +
          '<span style="font-size:' + (size - 4) + 'px">' + Math.round(c.value) + '</span>' +
          '</div>',
        iconSize: [50, 36],
        iconAnchor: [25, 18],
      });

      var marker = L.marker([c.lat, c.lon], { icon: icon, interactive: true });
      marker.on("click", function(e) {
        L.DomEvent.stopPropagation(e);
        if (centerDeleteMode) {
          // Delete this center
          masterCenters.splice(cIdx, 1);
          renderCentersOnAllPanels();
          setStatus("Centro eliminado");
        } else {
          // Toggle case: A->a->A / B->b->B
          toggleCenterCase(cIdx);
        }
      });
      marker.addTo(layer);
    });
    layer.addTo(map);
    centerLayers[i] = layer;
  });
}

function toggleCenterCase(idx) {
  var c = masterCenters[idx];
  if (!c) return;
  if (c.label === c.label.toUpperCase()) {
    c.label = c.label.toLowerCase();
  } else {
    c.label = c.label.toUpperCase();
  }
  c.primary = c.label === c.label.toUpperCase();
  renderCentersOnAllPanels();
  setStatus("Centro " + c.label + " (" + Math.round(c.value) + " hPa)");
}

function toggleCenterDeleteMode() {
  var wasActive = centerDeleteMode;
  _deactivateAllModes();
  if (!wasActive) {
    centerDeleteMode = true;
    updateModeIndicator();
    setStatus("Modo borrar centros: click en un A/B para eliminarlo");
  } else {
    setStatus("Modo borrar centros desactivado");
  }
}

function addCenterAtClick() {
  if (!maps[0]) return;
  _deactivateAllModes();
  setStatus("Click en el mapa para anadir un centro de presion");
  maps[0].once("click", function(e) {
    var lat = Math.round(e.latlng.lat * 100) / 100;
    var lon = Math.round(e.latlng.lng * 100) / 100;
    var type = prompt("Tipo de centro:\nH = Anticiclon (A)\nL = Borrasca (B)", "L");
    if (!type || (type !== "H" && type !== "L")) {
      setStatus("Cancelado");
      return;
    }
    var value = parseFloat(prompt("Presion (hPa):", type === "H" ? "1025" : "1000"));
    if (isNaN(value)) {
      setStatus("Cancelado");
      return;
    }
    var label = type === "H" ? "A" : "B";
    masterCenters.push({
      id: "manual_" + Date.now(),
      type: type,
      lat: lat,
      lon: lon,
      value: value,
      primary: true,
      name: "",
      label: label,
    });
    renderCentersOnAllPanels();
    setStatus("Centro " + label + " anadido en " + lat.toFixed(1) + ", " + lon.toFixed(1));
  });
}

// ==========================================================================
// Actions
// ==========================================================================
async function detectFronts() {
  showLoading();
  setStatus("Detectando frentes...");
  try {
    var resp = await fetch("/api/fronts/detect");
    var geojson = await resp.json();
    pushUndo();
    masterFronts = geojson;
    renderFrontsOnAllPanels();
    var n = geojson.features ? geojson.features.length : 0;
    setStatus(n + " frentes detectados. Click en un frente para eliminarlo.");
  } catch (e) {
    setStatus("Error detectando: " + e.message);
  } finally {
    hideLoading();
  }
}

async function saveFronts() {
  try {
    var resp1 = await fetch("/api/fronts", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterFronts),
    });
    var data1 = await resp1.json();
    // Also save edited centers
    var resp2 = await fetch("/api/centers", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterCenters),
    });
    var data2 = await resp2.json();
    setStatus("Guardado: " + data1.n_fronts + " frentes, " + data2.n_centers + " centros");
  } catch (e) {
    setStatus("Error guardando: " + e.message);
  }
}


function flipAllFronts() {
  pushUndo();
  (masterFronts.features || []).forEach(function(f) {
    if (f.properties) {
      f.properties.flip = !f.properties.flip;
      f.properties.flip_symbols = f.properties.flip;
    }
  });
  renderFrontsOnAllPanels();
  setStatus("Simbolos invertidos");
}

function _getOverlayParams() {
  var params = "";
  if (document.getElementById("precip-check").checked) params += "&precip=true";
  if (document.getElementById("wind-850-check").checked) params += "&wind_levels=850";
  if (document.getElementById("wind-700-check").checked) params += "&wind_levels=700";
  return params;
}

async function exportMap(clean) {
  var fieldName = "none";
  if (!clean) {
    var sel = document.querySelector('.panel-field-select[data-panel-idx="0"]');
    if (sel) fieldName = sel.value;
  }
  // Guardar frentes al backend antes de exportar (para preservar flip y ediciones)
  try {
    await fetch("/api/fronts", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterFronts),
    });
  } catch (e) {
    console.warn("No se pudieron guardar frentes antes de exportar:", e);
  }
  var url = "/api/export?field=" + encodeURIComponent(fieldName) + "&clean=" + (clean ? "true" : "false") + _getOverlayParams();
  setStatus("Exportando mapa Lambert" + (clean ? " (limpio)" : " (" + fieldName + ")") + "...");
  window.open(url, "_blank");
}

async function exportMosaic() {
  // Recopilar campos de cada panel visible
  var fields = [];
  document.querySelectorAll(".panel-field-select").forEach(function(sel) {
    fields.push(sel.value || "none");
  });
  if (fields.length === 0) { setStatus("No hay paneles visibles"); return; }

  // Guardar frentes al backend
  try {
    await fetch("/api/fronts", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterFronts),
    });
  } catch (e) {
    console.warn("No se pudieron guardar frentes antes de exportar:", e);
  }

  var layout = parseLayout();
  var params = "cols=" + layout.cols + "&rows=" + layout.rows;
  fields.forEach(function(f) { params += "&fields=" + encodeURIComponent(f); });
  params += _getOverlayParams();
  var url = "/api/export/mosaic?" + params;
  setStatus("Exportando mosaico " + layout.cols + "x" + layout.rows + " en Lambert...");
  window.open(url, "_blank");
}

// ==========================================================================
// Edit mode: select front + drag vertices
// ==========================================================================

function clearEditSelection() {
  // Remove vertex markers from panel 0
  vertexMarkers.forEach(function(m) { m.remove(); });
  vertexMarkers = [];
  // Remove highlight polylines from all panels
  editHighlights.forEach(function(hl) { hl.remove(); });
  editHighlights = [];
  selectedFeature = null;
}

function selectFrontForEdit(feature) {
  clearEditSelection();
  selectedFeature = feature;
  var coords = feature.geometry.coordinates;
  var latlngs = coords.map(function(c) { return [c[1], c[0]]; });

  // Highlight polyline on all panels
  maps.forEach(function(map) {
    if (!map) return;
    var hl = L.polyline(latlngs, {
      color: "#FFD700", weight: 5, opacity: 0.7, interactive: false,
    }).addTo(map);
    editHighlights.push(hl);
  });

  // Draggable vertex markers on panel 0 only (using vertexEdit pane for z-index)
  var map0 = maps[0];
  if (!map0) return;

  var vertexIcon = L.divIcon({
    className: "vertex-marker",
    iconSize: [14, 14],
    iconAnchor: [7, 7],
  });

  coords.forEach(function(coord, idx) {
    var marker = L.marker([coord[1], coord[0]], {
      icon: vertexIcon,
      draggable: true,
      pane: "vertexEdit",
    }).addTo(map0);

    // Prevent map click (deselect) when interacting with vertex markers
    marker.on("mousedown", function(e) { L.DomEvent.stopPropagation(e); });

    marker.on("dragstart", function() { pushUndo(); });

    marker.on("drag", function(e) {
      var pos = e.target.getLatLng();
      // Update GeoJSON coordinates
      feature.geometry.coordinates[idx] = [pos.lng, pos.lat];
      // Update highlight polylines in real time
      var newLatLngs = feature.geometry.coordinates.map(function(c) {
        return [c[1], c[0]];
      });
      editHighlights.forEach(function(hl) { hl.setLatLngs(newLatLngs); });
    });

    marker.on("dragend", function() {
      // Re-render WMO symbols on all panels with new geometry
      renderFrontsOnAllPanels();
      // Re-select to refresh highlights and vertex positions
      selectFrontForEdit(feature);
    });

    vertexMarkers.push(marker);
  });

  var ft = feature.properties.front_type || "?";
  setStatus("Editando frente " + ft + " (" + coords.length + " vertices). Arrastra vertices para deformar.");
}

function selectFrontForSplit(feature) {
  clearEditSelection();
  selectedFeature = feature;
  var coords = feature.geometry.coordinates;
  var latlngs = coords.map(function(c) { return [c[1], c[0]]; });

  // Highlight on all panels
  maps.forEach(function(map) {
    if (!map) return;
    var hl = L.polyline(latlngs, {
      color: "#ff4444", weight: 5, opacity: 0.6, interactive: false,
    }).addTo(map);
    editHighlights.push(hl);
  });

  // Split markers on panel 0 (not first/last  can't split at endpoints)
  var map0 = maps[0];
  if (!map0) return;

  var splitIcon = L.divIcon({
    className: "split-marker",
    iconSize: [14, 14],
    iconAnchor: [7, 7],
  });

  for (var idx = 1; idx < coords.length - 1; idx++) {
    (function(splitIdx) {
      var marker = L.marker([coords[splitIdx][1], coords[splitIdx][0]], {
        icon: splitIcon,
        draggable: false,
        pane: "vertexEdit",
      }).addTo(map0);

      marker.on("mousedown", function(e) { L.DomEvent.stopPropagation(e); });

      marker.on("click", function(e) {
        L.DomEvent.stopPropagation(e);
        splitFrontAtVertex(feature, splitIdx);
      });

      vertexMarkers.push(marker);
    })(idx);
  }

  var ft = feature.properties.front_type || "?";
  setStatus("Dividir frente " + ft + ": click en un vertice rojo para cortar (" + (coords.length - 2) + " puntos de corte)");
}

function splitFrontAtVertex(feature, splitIdx) {
  var coords = feature.geometry.coordinates;
  if (splitIdx < 1 || splitIdx >= coords.length - 1) return;
  pushUndo();

  // First half: [0..splitIdx] (inclusive)
  var coords1 = coords.slice(0, splitIdx + 1);
  // Second half: [splitIdx..end] (splitIdx is shared)
  var coords2 = coords.slice(splitIdx);

  // Minimum 2 points per segment
  if (coords1.length < 2 || coords2.length < 2) {
    setStatus("No se puede dividir: segmentos demasiado cortos");
    return;
  }

  // Update original feature with first half
  feature.geometry.coordinates = coords1;

  // Create new feature for second half
  var newFeature = {
    type: "Feature",
    properties: {
      front_type: feature.properties.front_type,
      id: "split_" + Date.now() + "_" + Math.random().toString(36).substr(2, 4),
      flip: feature.properties.flip || false,
      flip_symbols: feature.properties.flip_symbols || false,
    },
    geometry: {
      type: "LineString",
      coordinates: coords2,
    },
  };

  // Insert new feature right after the original
  var origIdx = masterFronts.features.indexOf(feature);
  if (origIdx >= 0) {
    masterFronts.features.splice(origIdx + 1, 0, newFeature);
  } else {
    masterFronts.features.push(newFeature);
  }

  clearEditSelection();
  renderFrontsOnAllPanels();
  setStatus("Frente dividido en vertice " + splitIdx + "  2 segmentos (" + coords1.length + " + " + coords2.length + " pts)");
}

function _deactivateAllModes() {
  if (editMode) {
    editMode = false;
    clearEditSelection();
  }
  if (splitMode) {
    splitMode = false;
    clearEditSelection();
  }
  if (deleteMode) { deleteMode = false; }
  if (centerDeleteMode) { centerDeleteMode = false; }
  if (selectMode) {
    selectMode = false;
    selectedFronts.clear();
    if (selectRectDrawer) { selectRectDrawer.disable(); selectRectDrawer = null; }
  }
  updateModeIndicator();
  updateSelectionUI();
}

function updateModeIndicator() {
  var ind = document.getElementById("mode-indicator");
  var menuBtns = document.querySelectorAll("#edit-menu button");
  menuBtns.forEach(function(b) { b.classList.remove("menu-active"); });

  if (editMode) {
    ind.textContent = "Editando";
    document.getElementById("btn-edit-mode").classList.add("menu-active");
  } else if (splitMode) {
    ind.textContent = "Dividir";
    document.getElementById("btn-split-mode").classList.add("menu-active");
  } else if (deleteMode) {
    ind.textContent = "Borrar frente";
    document.getElementById("btn-delete-mode").classList.add("menu-active");
  } else if (centerDeleteMode) {
    ind.textContent = "Borrar centro";
    document.getElementById("btn-center-delete").classList.add("menu-active");
  } else if (selectMode) {
    ind.textContent = "Seleccionar";
    document.getElementById("btn-select-mode").classList.add("menu-active");
  } else {
    ind.textContent = "";
  }
}

function toggleEditMode() {
  var wasActive = editMode;
  _deactivateAllModes();
  if (!wasActive) {
    editMode = true;
    updateModeIndicator();
    setStatus("Modo editar: click en un frente para mover vertices");
  } else {
    setStatus("Modo editar desactivado");
  }
}

function toggleSplitMode() {
  var wasActive = splitMode;
  _deactivateAllModes();
  if (!wasActive) {
    splitMode = true;
    updateModeIndicator();
    setStatus("Modo dividir: click en un frente, luego click en un vertice para cortar");
  } else {
    setStatus("Modo dividir desactivado");
  }
}

function toggleDeleteMode() {
  var wasActive = deleteMode;
  _deactivateAllModes();
  if (!wasActive) {
    deleteMode = true;
    updateModeIndicator();
    setStatus("Modo borrar: click en un frente para eliminarlo");
  } else {
    setStatus("Modo borrar desactivado");
  }
}

// ==========================================================================
// Select mode: select fronts, reassign type, delete batch
// ==========================================================================

function updateSelectionUI() {
  var n = selectedFronts.size;
  document.getElementById("sel-count").textContent = n > 0 ? n + " sel." : "";
}

function toggleSelectMode() {
  var wasActive = selectMode;
  _deactivateAllModes();
  if (!wasActive) {
    selectMode = true;
    updateModeIndicator();
    updateSelectionUI();
    setStatus("Modo seleccion: click en frentes o usa 'Seleccionar por area'");
  } else {
    renderFrontsOnAllPanels();
    setStatus("Modo seleccion desactivado");
  }
}

function startRectangleSelect() {
  if (!maps[0]) return;
  if (selectRectDrawer) { selectRectDrawer.disable(); selectRectDrawer = null; }
  selectRectDrawer = new L.Draw.Rectangle(maps[0], {
    shapeOptions: { color: "#FFD700", weight: 2, fillOpacity: 0.15 }
  });
  selectRectDrawer.enable();
  setStatus("Dibuja un rectangulo sobre los frentes que quieras seleccionar");
}

function handleRectangleCreated(e) {
  if (!selectMode) return;
  var layer = e.layer;
  var bounds = layer.getBounds();

  // Find fronts that have at least one coordinate inside the rectangle
  (masterFronts.features || []).forEach(function(feature, idx) {
    var coords = feature.geometry && feature.geometry.coordinates;
    if (!coords) return;
    for (var j = 0; j < coords.length; j++) {
      var ll = L.latLng(coords[j][1], coords[j][0]);
      if (bounds.contains(ll)) {
        selectedFronts.add(idx);
        break;
      }
    }
  });

  // Don't add the rectangle to the map permanently
  if (layer._map) layer._map.removeLayer(layer);
  selectRectDrawer = null;
  updateSelectionUI();
  renderFrontsOnAllPanels();
  setStatus(selectedFronts.size + " frentes seleccionados");
}

function assignTypeToSelected() {
  if (selectedFronts.size === 0) return;
  pushUndo();
  var newType = getSelectedFrontType();
  selectedFronts.forEach(function(idx) {
    var f = masterFronts.features[idx];
    if (f && f.properties) {
      f.properties.front_type = newType;
    }
  });
  renderFrontsOnAllPanels();
  setStatus(selectedFronts.size + " frentes reasignados a '" + newType + "'");
}

function deleteSelectedFronts() {
  if (selectedFronts.size === 0) return;
  pushUndo();
  var count = selectedFronts.size;
  // Delete in reverse index order to avoid shifting
  var indices = Array.from(selectedFronts).sort(function(a, b) { return b - a; });
  indices.forEach(function(idx) {
    masterFronts.features.splice(idx, 1);
  });
  selectedFronts.clear();
  updateSelectionUI();
  renderFrontsOnAllPanels();
  setStatus(count + " frentes eliminados");
}

// ==========================================================================
// Event bindings
// ==========================================================================
document.getElementById("btn-load").addEventListener("click", loadData);
document.getElementById("btn-detect").addEventListener("click", detectFronts);
document.getElementById("btn-save").addEventListener("click", saveFronts);

// Export dropdown toggle
document.getElementById("btn-export-toggle").addEventListener("click", function(e) {
  e.stopPropagation();
  var menu = document.getElementById("export-menu");
  menu.classList.toggle("open");
});
document.addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  document.getElementById("edit-menu").classList.remove("open");
});
document.getElementById("btn-export").addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  exportMap(false);
});
document.getElementById("btn-export-clean").addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  exportMap(true);
});
document.getElementById("btn-export-mosaic").addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  exportMosaic();
});

document.getElementById("precip-check").addEventListener("change", loadPrecipOverlay);
document.getElementById("wind-850-check").addEventListener("change", loadWindOverlays);
document.getElementById("wind-700-check").addEventListener("change", loadWindOverlays);

// Edit dropdown toggle
document.getElementById("btn-edit-toggle").addEventListener("click", function(e) {
  e.stopPropagation();
  document.getElementById("edit-menu").classList.toggle("open");
  document.getElementById("export-menu").classList.remove("open");
});
// Close edit menu on outside click (handled in existing document click listener below)

document.getElementById("btn-edit-mode").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  toggleEditMode();
});
document.getElementById("btn-split-mode").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  toggleSplitMode();
});
document.getElementById("btn-delete-mode").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  toggleDeleteMode();
});
document.getElementById("btn-select-mode").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  toggleSelectMode();
});
document.getElementById("btn-select-rect").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  startRectangleSelect();
});
document.getElementById("btn-assign-type").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  assignTypeToSelected();
});
document.getElementById("btn-delete-selected").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  deleteSelectedFronts();
});
document.getElementById("btn-flip").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  flipAllFronts();
});
document.getElementById("btn-center-delete").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  toggleCenterDeleteMode();
});
document.getElementById("btn-center-add").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  addCenterAtClick();
});
document.getElementById("btn-undo").addEventListener("click", function() {
  document.getElementById("edit-menu").classList.remove("open");
  undoAction();
});

// Keyboard shortcuts
document.addEventListener("keydown", function(e) {
  // Ctrl+Z: undo
  if ((e.ctrlKey || e.metaKey) && e.key === "z") {
    e.preventDefault();
    undoAction();
    return;
  }
  if (e.key === "Escape") {
    if (selectMode && selectedFronts.size > 0) {
      selectedFronts.clear();
      updateSelectionUI();
      renderFrontsOnAllPanels();
      setStatus("Seleccion limpiada");
    } else if ((editMode || splitMode) && selectedFeature) {
      clearEditSelection();
      setStatus("Frente deseleccionado");
    } else if (editMode || splitMode || deleteMode || selectMode) {
      _deactivateAllModes();
      renderFrontsOnAllPanels();
      setStatus("Modo desactivado");
    }
  }
});

document.getElementById("layout-select").addEventListener("change", function() {
  var layout = parseLayout();
  rebuildMosaic(layout.cols, layout.rows);
});

document.getElementById("front-type-select").addEventListener("change", updateAllDrawOptions);

// ==========================================================================
// Init
// ==========================================================================
(async function init() {
  await loadCoastlines();
  var layout = parseLayout();
  rebuildMosaic(layout.cols, layout.rows);
  document.getElementById("front-type-swatch").style.background = getSelectedFrontColor();
  setStatus("Listo. Introduzca fecha y pulse 'Cargar datos'.");
})();
</script>

</body>
</html>
