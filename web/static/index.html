<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MAPA_FRENTES Web</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: "Segoe UI", Arial, sans-serif; background: #0a0a1a; color: #e0e0e0; }

    #toolbar {
      height: 44px; background: #16213e; display: flex;
      align-items: center; padding: 0 10px; gap: 8px;
      border-bottom: 2px solid #0f3460; flex-wrap: nowrap;
      overflow: visible; position: relative; z-index: 9500;
    }
    #toolbar label { color: #8899aa; font-size: 11px; white-space: nowrap; }
    #toolbar input, #toolbar select {
      padding: 4px 8px; border-radius: 3px; border: 1px solid #0f3460;
      background: #1a1a2e; color: #e0e0e0; font-size: 12px;
    }
    #toolbar button {
      padding: 5px 14px; border-radius: 4px; border: 1px solid #0f3460;
      background: #1a1a2e; color: #e0e0e0; cursor: pointer;
      font-size: 12px; white-space: nowrap; transition: background 0.2s;
    }
    #toolbar button:hover { background: #0f3460; }
    #toolbar button:disabled { opacity: 0.4; cursor: not-allowed; }
    #toolbar button.primary { background: #1a5276; border-color: #2980b9; }
    #toolbar button.primary:hover { background: #2980b9; }
    #toolbar button.danger { border-color: #c0392b; }
    #toolbar button.danger:hover { background: #c0392b; }
    .spacer { flex-grow: 1; }
    #status { color: #53a653; font-size: 11px; white-space: nowrap; max-width: 350px; overflow: hidden; text-overflow: ellipsis; }
    .tb-sep { width: 1px; height: 24px; background: #0f3460; flex-shrink: 0; }

    #front-type-swatch {
      display: inline-block; width: 14px; height: 14px;
      border-radius: 2px; vertical-align: middle; margin-left: 2px;
      border: 1px solid #555; background: #0033BB;
    }

    #mosaic {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      height: calc(100vh - 44px);
      gap: 2px; background: #0a0a1a;
    }
    .panel { position: relative; background: #1a1a2e; overflow: hidden; }
    .panel-field-select {
      position: absolute; top: 4px; left: 4px; z-index: 800;
      background: rgba(0,0,0,0.75); color: #fff; padding: 2px 6px;
      font-size: 11px; border-radius: 3px; border: 1px solid #0f3460;
      cursor: pointer; max-width: 160px;
    }
    .panel .leaflet-container { width: 100%; height: 100%; }
    .leaflet-container { background: #c8dff0 !important; }

    #loading {
      display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); z-index: 10000;
      justify-content: center; align-items: center;
    }
    #loading.active { display: flex; }
    #loading .spinner {
      width: 40px; height: 40px; border: 4px solid #333;
      border-top-color: #2980b9; border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #toolbar button.active-mode { background: #c0392b; border-color: #e74c3c; color: #fff; }

    .color-legend {
      position: absolute; bottom: 8px; left: 8px; z-index: 800;
      background: rgba(0,0,0,0.72); border-radius: 4px; padding: 4px 6px;
      font-size: 9px; color: #eee; pointer-events: none;
      max-width: 140px; line-height: 1.3;
    }
    .color-legend .cl-bar {
      width: 100%; height: 8px; border-radius: 2px; margin: 2px 0;
    }
    .color-legend .cl-labels {
      display: flex; justify-content: space-between; font-size: 8px;
    }
    .color-legend .cl-title {
      font-size: 9px; font-weight: 600; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }

    /* WMO symbol markers: no shadow, no default icon styles, allow rotation overflow */
    .wmo-symbol { background: none !important; border: none !important; overflow: visible !important; }

    /* Export dropdown */
    .export-dropdown {
      position: relative; display: inline-block;
    }
    .export-dropdown-btn {
      padding: 5px 14px; border-radius: 4px; border: 1px solid #0f3460;
      background: #1a1a2e; color: #e0e0e0; cursor: pointer;
      font-size: 12px; white-space: nowrap; transition: background 0.2s;
    }
    .export-dropdown-btn:hover { background: #0f3460; }
    .export-dropdown-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .export-dropdown-menu {
      display: none; position: absolute; top: 100%; left: 0;
      background: #16213e; border: 1px solid #0f3460; border-radius: 4px;
      z-index: 9000; min-width: 200px; margin-top: 2px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    .export-dropdown-menu.open { display: block; }
    .export-dropdown-menu button {
      display: block; width: 100%; text-align: left;
      padding: 8px 14px; border: none; background: none;
      color: #e0e0e0; font-size: 12px; cursor: pointer;
      white-space: nowrap;
    }
    .export-dropdown-menu button:hover { background: #0f3460; }
    .export-dropdown-menu hr {
      border: none; border-top: 1px solid #0f3460; margin: 2px 0;
    }

    /* Vertex edit markers */
    .vertex-marker {
      width: 12px; height: 12px; border-radius: 50%;
      background: #fff; border: 2px solid #222;
      cursor: grab; box-shadow: 0 0 3px rgba(0,0,0,0.4);
    }
    .vertex-marker:hover { background: #ff0; border-color: #000; }
    .vertex-marker:active { cursor: grabbing; }
  </style>
</head>
<body>

<div id="toolbar">
  <label>Fecha:</label>
  <input type="text" id="date-input" placeholder="YYYYMMDDHH" size="11" title="Ej: 2026021400. Vacio = ultimo disponible" />
  <label>Step:</label>
  <select id="step-select">
    <option value="0" selected>T+000</option>
    <option value="6">T+006</option>
    <option value="12">T+012</option>
    <option value="24">T+024</option>
    <option value="48">T+048</option>
    <option value="72">T+072</option>
  </select>
  <label>Layout:</label>
  <select id="layout-select">
    <option value="1x1">1 mapa</option>
    <option value="2x2" selected>2x2</option>
    <option value="3x2">3x2</option>
    <option value="3x3">3x3</option>
    <option value="4x3">4x3</option>
  </select>
  <button id="btn-load" class="primary">Cargar datos</button>
  <button id="btn-detect" disabled>Detectar frentes</button>

  <div class="tb-sep"></div>
  <label>Tipo frente:</label>
  <select id="front-type-select">
    <option value="cold">Frio</option>
    <option value="warm">Calido</option>
    <option value="occluded">Ocluido</option>
    <option value="stationary">Estacionario</option>
    <option value="instability_line">Lin. inestabilidad</option>
  </select>
  <span id="front-type-swatch"></span>
  <div class="tb-sep"></div>

  <button id="btn-save" disabled>Guardar</button>
  <div class="export-dropdown">
    <button class="export-dropdown-btn" id="btn-export-toggle" disabled>Exportar &#9662;</button>
    <div class="export-dropdown-menu" id="export-menu">
      <button id="btn-export">Con campo de fondo</button>
      <button id="btn-export-clean">Sin campo (limpio)</button>
      <hr/>
      <button id="btn-export-mosaic">Mosaico completo</button>
    </div>
  </div>
  <div class="tb-sep"></div>
  <label><input type="checkbox" id="precip-check" /> Precip</label>
  <label><input type="checkbox" id="wind-850-check" /> V850</label>
  <label><input type="checkbox" id="wind-700-check" /> V700</label>
  <div class="tb-sep"></div>
  <button id="btn-flip" disabled title="Invertir simbolos de todos los frentes">Invertir</button>
  <button id="btn-edit-mode" disabled title="Activar modo editar: click en un frente para mover vertices">Editar</button>
  <button id="btn-delete-mode" disabled title="Activar modo borrar: click en un frente para eliminarlo">Borrar</button>
  <div class="spacer"></div>
  <span id="status">Listo</span>
</div>

<div id="mosaic"></div>
<div id="loading"><div class="spinner"></div></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
// ==========================================================================
// WMO Front Symbols - Direct SVG markers (no polylineDecorator dependency)
// ==========================================================================

/**
 * Compute evenly-spaced sample points along a polyline in pixel space.
 * Returns array of { latlng, angleDeg } where angleDeg is the line direction.
 */
function samplePointsAlongLine(latlngs, spacingPx, map) {
  if (!latlngs || latlngs.length < 2 || !map) return [];

  // Convert to pixel coords
  var pts = latlngs.map(function(ll) { return map.latLngToContainerPoint(ll); });

  // Compute cumulative pixel distance
  var cumDist = [0];
  for (var i = 1; i < pts.length; i++) {
    var dx = pts[i].x - pts[i-1].x;
    var dy = pts[i].y - pts[i-1].y;
    cumDist.push(cumDist[i-1] + Math.sqrt(dx*dx + dy*dy));
  }
  var totalLen = cumDist[cumDist.length - 1];
  if (totalLen < spacingPx * 0.5) return [];

  // Sample at even intervals starting at spacingPx/2
  var samples = [];
  var offset = spacingPx * 0.4;  // first symbol offset
  var segIdx = 0;

  for (var d = offset; d < totalLen - spacingPx * 0.3; d += spacingPx) {
    // Find segment containing distance d
    while (segIdx < cumDist.length - 2 && cumDist[segIdx + 1] < d) segIdx++;

    var segLen = cumDist[segIdx + 1] - cumDist[segIdx];
    if (segLen < 0.01) continue;
    var t = (d - cumDist[segIdx]) / segLen;

    // Interpolate position
    var px = pts[segIdx].x + t * (pts[segIdx + 1].x - pts[segIdx].x);
    var py = pts[segIdx].y + t * (pts[segIdx + 1].y - pts[segIdx].y);

    // Direction angle (degrees, 0 = right, CW positive for CSS transform)
    var dx2 = pts[segIdx + 1].x - pts[segIdx].x;
    var dy2 = pts[segIdx + 1].y - pts[segIdx].y;
    var angleDeg = Math.atan2(dy2, dx2) * 180 / Math.PI;

    var ll = map.containerPointToLatLng(L.point(px, py));
    samples.push({ latlng: ll, angleDeg: angleDeg });
  }

  return samples;
}

/**
 * Helper: rotate point (x,y) around origin by angle in radians.
 */
function _rot(x, y, cos_a, sin_a) {
  return [x * cos_a - y * sin_a, x * sin_a + y * cos_a];
}

/**
 * Create pre-rotated triangle SVG (no CSS transform needed).
 * Returns { html, size } where the SVG is a square of side `size`,
 * symbol centered, already rotated to `angleDeg`.
 * The anchor point is always the center of the SVG = point on the front line.
 *
 * angleDeg: direction the apex should point (screen coords, 0=right, CW positive).
 * h: height of triangle (apex distance from base center).
 */
function makeTriangleSVG(h, color, angleDeg) {
  var hw = h * 0.4;  // half base width
  var s = Math.ceil(h * 2) + 4;  // square SVG side
  var c = s / 2;  // center

  // Unrotated: base at origin, apex pointing UP (angle = -90 deg screen)
  // Vertices relative to base center (0,0):
  var verts = [[-hw, 0], [0, -h], [hw, 0]];

  // We want apex to point at angleDeg. Unrotated apex points at -90.
  // Rotation needed: angleDeg - (-90) = angleDeg + 90
  var rad = (angleDeg + 90) * Math.PI / 180;
  var cos_a = Math.cos(rad), sin_a = Math.sin(rad);

  var pts = verts.map(function(v) {
    var r = _rot(v[0], v[1], cos_a, sin_a);
    return (c + r[0]).toFixed(1) + ',' + (c + r[1]).toFixed(1);
  });

  return {
    html: '<svg width="' + s + '" height="' + s + '" viewBox="0 0 ' + s + ' ' + s + '" xmlns="http://www.w3.org/2000/svg">' +
      '<polygon points="' + pts.join(' ') + '" fill="' + color + '" stroke="' + color + '" stroke-width="0.5"/></svg>',
    size: s,
  };
}

/**
 * Create pre-rotated semicircle SVG (no CSS transform needed).
 * Returns { html, size }.
 *
 * angleDeg: direction the bulge should point (screen coords).
 * r: radius of semicircle.
 */
function makeSemicircleSVG(r, color, angleDeg) {
  if (r < 2) r = 2;
  var s = Math.ceil(r * 2) + 4;  // square SVG side
  var c = s / 2;  // center

  // Unrotated: flat edge horizontal at origin, bulge pointing UP (-90 deg)
  // Points relative to center of flat edge (0,0):
  var nSeg = 14;
  var verts = [];
  for (var i = 0; i <= nSeg; i++) {
    var t = Math.PI * i / nSeg;  // 0 to PI
    verts.push([-r * Math.cos(t), -r * Math.sin(t)]);  // bulges UP (negative Y)
  }

  // Rotate so bulge points at angleDeg (same logic as triangle)
  var rad = (angleDeg + 90) * Math.PI / 180;
  var cos_a = Math.cos(rad), sin_a = Math.sin(rad);

  var pts = verts.map(function(v) {
    var rv = _rot(v[0], v[1], cos_a, sin_a);
    return (c + rv[0]).toFixed(1) + ',' + (c + rv[1]).toFixed(1);
  });

  return {
    html: '<svg width="' + s + '" height="' + s + '" viewBox="0 0 ' + s + ' ' + s + '" xmlns="http://www.w3.org/2000/svg">' +
      '<polygon points="' + pts.join(' ') + '" fill="' + color + '" stroke="' + color + '" stroke-width="0.5"/></svg>',
    size: s,
  };
}

/**
 * Place WMO symbol markers along a polyline.
 * Symbols are pre-rotated SVGs centered on the line point (no CSS transform).
 *
 * symbolType: "triangle", "semicircle", "both" (occluded), "stationary"
 * opts.flip: if true, symbols point to the opposite side
 */
function createWMOSymbolMarkers(latlngs, map, symbolType, color, opts) {
  opts = opts || {};
  var zoom = map.getZoom();
  var triH     = (zoom >= 7) ? 18 : (zoom >= 5 ? 14 : 10);
  var semiR    = (zoom >= 7) ? 9  : (zoom >= 5 ? 7  : 5);
  var spacing  = (zoom >= 7) ? 50 : (zoom >= 5 ? 40 : 30);
  var flip = opts.flip || false;

  var samples = samplePointsAlongLine(latlngs, spacing, map);
  var markers = [];

  samples.forEach(function(sample, idx) {
    // Direction perpendicular to line, pointing RIGHT of line direction
    var perpAngle = sample.angleDeg + 90;
    if (flip) perpAngle += 180;

    var sym, symSize;

    if (symbolType === "triangle") {
      sym = makeTriangleSVG(triH, color, perpAngle);

    } else if (symbolType === "semicircle") {
      sym = makeSemicircleSVG(semiR, color, perpAngle);

    } else if (symbolType === "both") {
      // Occluded: alternate triangle and semicircle
      if (idx % 2 === 0) {
        sym = makeTriangleSVG(triH, color, perpAngle);
      } else {
        sym = makeSemicircleSVG(semiR, color, perpAngle);
      }

    } else if (symbolType === "stationary") {
      // Blue triangles on one side, red semicircles on the opposite
      if (idx % 2 === 0) {
        sym = makeTriangleSVG(triH, "#0033BB", perpAngle);
      } else {
        sym = makeSemicircleSVG(semiR, "#CC0000", perpAngle + 180);
      }

    } else {
      return;
    }

    symSize = sym.size;
    var half = symSize / 2;

    var icon = L.divIcon({
      className: "wmo-symbol",
      html: sym.html,
      iconSize: [symSize, symSize],
      iconAnchor: [half, half],  // center of SVG = point on line
    });

    markers.push(L.marker(sample.latlng, {
      icon: icon,
      interactive: false,
      pane: "fronts",
    }));
  });

  return markers;
}

// ==========================================================================
// Config
// ==========================================================================
var DEFAULT_FIELDS = [
  "theta_e_850", "grad_theta_e_850", "temp_advection_850",
  "wind_speed_850", "vorticity_850", "thickness_1000_500",
  "theta_e_700", "grad_t_850", "wind_speed_500",
  "temp_850", "humidity_850", "theta_e_850",
];

var FRONT_COLORS = {
  cold: "#0033BB", warm: "#CC0000", occluded: "#8800AA",
  cold_occluded: "#6600CC", warm_occluded: "#AA0088",
  warm_seclusion: "#DD0066", stationary: "#006600",
  instability_line: "#CC4400",
};

var DEFAULT_CENTER = [45, -15];
var DEFAULT_ZOOM = 4;

// ==========================================================================
// State
// ==========================================================================
var maps = [];
var fieldOverlays = [];
var precipOverlays = []; // precipitation PNG overlays per panel
var windLayers = [];     // wind vector canvas layers per panel
var isobarLayers = [];
var centerLayers = [];
var coastlineLayers = [];
var frontLayers = [];
var drawControls = [];

var dataBounds = null;
var dataLoaded = false;
var availableFields = null;
var coastlineData = null;
var masterFronts = { type: "FeatureCollection", features: [] };
var deleteMode = false;
var editMode = false;
var selectedFeature = null;
var vertexMarkers = [];       // L.marker arrastrables (solo panel 0)
var editHighlights = [];      // L.polyline resaltadas (todos los paneles)
var colorLegends = [];  // DOM elements per panel

// ==========================================================================
// UI helpers
// ==========================================================================
function setStatus(msg) { document.getElementById("status").textContent = msg; }
function showLoading() { document.getElementById("loading").classList.add("active"); }
function hideLoading() { document.getElementById("loading").classList.remove("active"); }
function setButtonsEnabled(loaded) {
  document.getElementById("btn-detect").disabled = !loaded;
  document.getElementById("btn-save").disabled = !loaded;
  document.getElementById("btn-export-toggle").disabled = !loaded;
  document.getElementById("btn-flip").disabled = !loaded;
  document.getElementById("btn-edit-mode").disabled = !loaded;
  document.getElementById("btn-delete-mode").disabled = !loaded;
}

function getSelectedFrontType() {
  return document.getElementById("front-type-select").value;
}
function getSelectedFrontColor() {
  return FRONT_COLORS[getSelectedFrontType()] || "#0033BB";
}

// ==========================================================================
// Front rendering
// ==========================================================================
function frontLineStyle(frontType) {
  var color = FRONT_COLORS[frontType] || "#0033BB";
  var dashArray = frontType === "instability_line" ? "8 4 2 4" : null;
  return { color: color, weight: 3, opacity: 0.9, dashArray: dashArray, pane: "fronts" };
}

/**
 * Determine WMO symbol type and color for a given front type.
 */
function getSymbolConfig(frontType) {
  switch (frontType) {
    case "cold":
    case "cold_occluded":
      return { symbolType: "triangle", color: FRONT_COLORS[frontType] };
    case "warm":
    case "warm_occluded":
    case "warm_seclusion":
      return { symbolType: "semicircle", color: FRONT_COLORS[frontType] };
    case "occluded":
      return { symbolType: "both", color: FRONT_COLORS.occluded };
    case "stationary":
      return { symbolType: "stationary", color: "#006600" };
    default:
      return null;  // instability_line: no symbols
  }
}

function renderFrontsOnAllPanels() {
  maps.forEach(function(map, i) {
    if (frontLayers[i]) {
      map.removeLayer(frontLayers[i]);
      frontLayers[i] = null;
    }

    var group = L.layerGroup().addTo(map);

    (masterFronts.features || []).forEach(function(feature) {
      var coords = feature.geometry && feature.geometry.coordinates;
      if (!coords || coords.length < 2) return;

      var latlngs = coords.map(function(c) { return L.latLng(c[1], c[0]); });
      var ft = (feature.properties && feature.properties.front_type) || "cold";

      // Draw the line
      var line = L.polyline(latlngs, frontLineStyle(ft)).addTo(group);

      // Click behavior depends on mode
      line.on("click", function(e) {
        L.DomEvent.stopPropagation(e);
        if (deleteMode) {
          // Delete this front
          var idx = masterFronts.features.indexOf(feature);
          if (idx >= 0) masterFronts.features.splice(idx, 1);
          renderFrontsOnAllPanels();
          setStatus("Frente eliminado");
        } else if (editMode) {
          // Select front for vertex editing
          selectFrontForEdit(feature);
        } else {
          // Flip symbol direction
          feature.properties.flip = !feature.properties.flip;
          feature.properties.flip_symbols = feature.properties.flip;
          renderFrontsOnAllPanels();
          setStatus("Simbolos invertidos (" + ft + ")");
        }
      });

      // WMO symbols as div markers
      var symCfg = getSymbolConfig(ft);
      if (symCfg) {
        var isFlipped = !!(feature.properties && feature.properties.flip);
        var markers = createWMOSymbolMarkers(latlngs, map, symCfg.symbolType, symCfg.color, { flip: isFlipped });
        markers.forEach(function(m) { m.addTo(group); });
      }
    });

    frontLayers[i] = group;
  });
}

// ==========================================================================
// Coastlines
// ==========================================================================
async function loadCoastlines() {
  if (coastlineData) return coastlineData;
  try {
    var resp = await fetch("/api/coastlines");
    coastlineData = await resp.json();
  } catch (e) {
    console.warn("No se pudieron cargar costas:", e);
    coastlineData = { type: "FeatureCollection", features: [] };
  }
  return coastlineData;
}

function addCoastlineToMap(map, idx) {
  if (!coastlineData) return;
  if (coastlineLayers[idx]) map.removeLayer(coastlineLayers[idx]);
  coastlineLayers[idx] = L.geoJSON(coastlineData, {
    pane: "coastlines",
    style: function(feature) {
      return {
        color: feature.properties.layer === "coastline" ? "#222" : "#777",
        weight: feature.properties.layer === "coastline" ? 1.3 : 0.5,
        opacity: 0.9,
        interactive: false,
      };
    },
  }).addTo(map);
}

// ==========================================================================
// Build / Rebuild mosaic
// ==========================================================================
function parseLayout() {
  var val = document.getElementById("layout-select").value;
  var parts = val.split("x").map(Number);
  return { cols: parts[0], rows: parts[1] };
}

function _createPanel(idx, mosaic, fieldKeys, fieldLabels) {
  var panel = document.createElement("div");
  panel.className = "panel";

  var sel = document.createElement("select");
  sel.className = "panel-field-select";
  sel.dataset.panelIdx = idx;

  // Opcion "Sin fondo" (mapa limpio)
  var noneOpt = document.createElement("option");
  noneOpt.value = "none";
  noneOpt.textContent = "Sin fondo";
  sel.appendChild(noneOpt);

  if (fieldKeys.length > 0) {
    fieldKeys.forEach(function(key) {
      var opt = document.createElement("option");
      opt.value = key;
      opt.textContent = fieldLabels[key] || key;
      sel.appendChild(opt);
    });
    var defField = DEFAULT_FIELDS[idx % DEFAULT_FIELDS.length];
    sel.value = fieldKeys.indexOf(defField) >= 0 ? defField : fieldKeys[idx % fieldKeys.length];
  } else {
    var opt = document.createElement("option");
    opt.value = DEFAULT_FIELDS[idx % DEFAULT_FIELDS.length];
    opt.textContent = opt.value;
    sel.appendChild(opt);
  }
  sel.addEventListener("change", function() { onPanelFieldChange(idx); });
  panel.appendChild(sel);

  var mapDiv = document.createElement("div");
  mapDiv.id = "map-" + idx;
  mapDiv.style.cssText = "width:100%;height:100%";
  panel.appendChild(mapDiv);
  mosaic.appendChild(panel);

  var map = L.map("map-" + idx, {
    center: DEFAULT_CENTER,
    zoom: DEFAULT_ZOOM,
    zoomControl: (idx === 0),
    attributionControl: false,
  });

  // Custom panes
  map.createPane("coastlines");
  map.getPane("coastlines").style.zIndex = 450;
  map.createPane("fronts");
  map.getPane("fronts").style.zIndex = 650;
  map.createPane("vertexEdit");
  map.getPane("vertexEdit").style.zIndex = 700;

  // Basemap
  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
    { opacity: 0.4, maxZoom: 12 }
  ).addTo(map);

  addCoastlineToMap(map, idx);

  fieldOverlays.push(null);
  precipOverlays.push(null);
  windLayers.push(null);
  isobarLayers.push(null);
  centerLayers.push(null);
  frontLayers.push(null);

  // Sync zoom/pan
  map.on("moveend", function() { syncMaps(idx); });

  // Re-render fronts on zoom (symbol sizes depend on zoom)
  // and refresh field images to rescale colors to viewport
  var _zoomRenderTimeout = null;
  map.on("zoomend", function() {
    if (_zoomRenderTimeout) clearTimeout(_zoomRenderTimeout);
    _zoomRenderTimeout = setTimeout(function() {
      renderFrontsOnAllPanels();
      if (dataLoaded) refreshFieldsForViewport();
    }, 300);
  });

  // Click on map background: deselect in edit mode
  map.on("click", function() {
    if (editMode && selectedFeature) {
      clearEditSelection();
      setStatus("Frente deseleccionado. Click en otro frente para editarlo.");
    }
  });

  maps.push(map);
  initDrawOnPanel(idx);
}

function rebuildMosaic(cols, rows) {
  maps.forEach(function(m) { m.remove(); });
  maps = [];
  fieldOverlays = [];
  precipOverlays = [];
  windLayers = [];
  isobarLayers = [];
  centerLayers = [];
  coastlineLayers = [];
  frontLayers = [];
  drawControls = [];
  colorLegends = [];

  var mosaic = document.getElementById("mosaic");
  mosaic.innerHTML = "";
  mosaic.style.gridTemplateColumns = "repeat(" + cols + ", 1fr)";
  mosaic.style.gridTemplateRows = "repeat(" + rows + ", 1fr)";

  var nPanels = cols * rows;
  var fieldKeys = availableFields ? Object.keys(availableFields) : [];
  var fieldLabels = availableFields || {};

  for (var i = 0; i < nPanels; i++) {
    _createPanel(i, mosaic, fieldKeys, fieldLabels);
  }

  if (dataLoaded) {
    loadFieldImages();
    loadIsobars();
    loadCenters();
    renderFrontsOnAllPanels();
  }
}

function _getDrawShapeOptions() {
  var ft = getSelectedFrontType();
  var color = getSelectedFrontColor();
  var dashArray = ft === "instability_line" ? "8 4 2 4" :
                  ft === "stationary" ? "6 3" : null;
  return { color: color, weight: 3, opacity: 0.9, dashArray: dashArray };
}

function _createDrawControl(shapeOptions) {
  return new L.Control.Draw({
    position: "topright",
    edit: false,
    draw: {
      polyline: { shapeOptions: shapeOptions },
      polygon: false, rectangle: false,
      circle: false, marker: false, circlemarker: false,
    },
  });
}

function initDrawOnPanel(panelIdx) {
  var dc = _createDrawControl(_getDrawShapeOptions());
  maps[panelIdx].addControl(dc);
  drawControls[panelIdx] = dc;

  maps[panelIdx].on(L.Draw.Event.CREATED, function(e) {
    var layer = e.layer;
    var selectedType = getSelectedFrontType();
    var geojson = layer.toGeoJSON();

    var feature = {
      type: "Feature",
      properties: {
        front_type: selectedType,
        id: "new_" + Date.now() + "_" + Math.random().toString(36).substr(2, 4)
      },
      geometry: geojson.geometry,
    };

    masterFronts.features.push(feature);
    renderFrontsOnAllPanels();
    setStatus("Frente " + selectedType + " dibujado");
  });
}

function updateAllDrawOptions() {
  document.getElementById("front-type-swatch").style.background = getSelectedFrontColor();
  var shapeOptions = _getDrawShapeOptions();

  maps.forEach(function(map, i) {
    if (drawControls[i]) map.removeControl(drawControls[i]);
    var dc = _createDrawControl(shapeOptions);
    map.addControl(dc);
    drawControls[i] = dc;
  });
}

function onPanelFieldChange(panelIdx) {
  if (!dataLoaded || !dataBounds) return;
  var sel = document.querySelector('.panel-field-select[data-panel-idx="' + panelIdx + '"]');
  if (!sel) return;
  loadSingleFieldImage(panelIdx, sel.value);
}

function _getViewportParams(map) {
  var b = map.getBounds();
  return "south=" + b.getSouth().toFixed(2) +
    "&north=" + b.getNorth().toFixed(2) +
    "&west=" + b.getWest().toFixed(2) +
    "&east=" + b.getEast().toFixed(2);
}

// Matplotlib colormaps approximated as CSS gradients (key subset)
var CMAP_CSS = {
  RdYlBu_r: "linear-gradient(to right, #313695, #4575b4, #74add1, #abd9e9, #e0f3f8, #ffffbf, #fee090, #fdae61, #f46d43, #d73027, #a50026)",
  coolwarm: "linear-gradient(to right, #3b4cc0, #6788ee, #9abbff, #c9d7ef, #edd1c2, #f7a889, #e26952, #b40426)",
  RdBu_r: "linear-gradient(to right, #053061, #2166ac, #4393c3, #92c5de, #d1e5f0, #f7f7f7, #fddbc7, #f4a582, #d6604d, #b2182b, #67001f)",
  YlOrRd: "linear-gradient(to right, #ffffcc, #ffeda0, #fed976, #feb24c, #fd8d3c, #fc4e2a, #e31a1c, #b10026)",
  viridis: "linear-gradient(to right, #440154, #482777, #3e4989, #31688e, #26828e, #1f9e89, #35b779, #6ece58, #b5de2b, #fde725)",
  BrBG: "linear-gradient(to right, #543005, #8c510a, #bf812d, #dfc27d, #f6e8c3, #f5f5f5, #c7eae5, #80cdc1, #35978f, #01665e, #003c30)",
  hot_r: "linear-gradient(to right, #ffffff, #ffff00, #ff8800, #ff0000, #880000, #000000)",
  Blues: "linear-gradient(to right, #f7fbff, #deebf7, #c6dbef, #9ecae1, #6baed6, #4292c6, #2171b5, #084594)",
  YlGnBu: "linear-gradient(to right, #ffffd9, #edf8b1, #c7e9b4, #7fcdbb, #41b6c4, #1d91c0, #225ea8, #0c2c84)",
  bwr: "linear-gradient(to right, #0000ff, #4444ff, #8888ff, #ccccff, #ffffff, #ffcccc, #ff8888, #ff4444, #ff0000)",
  PiYG_r: "linear-gradient(to right, #276419, #4d9221, #7fbc41, #b8e186, #e6f5d0, #f7f7f7, #fde0ef, #f1b6da, #de77ae, #c51b7d, #8e0152)",
};

function _cmapToCSS(cmapName) {
  return CMAP_CSS[cmapName] || CMAP_CSS.viridis;
}

function _formatValue(v) {
  var abs = Math.abs(v);
  if (abs === 0) return "0";
  if (abs >= 1000) return v.toFixed(0);
  if (abs >= 10) return v.toFixed(1);
  if (abs >= 0.1) return v.toFixed(2);
  return v.toExponential(1);
}

function updateColorLegend(panelIdx, info) {
  var panel = document.querySelectorAll(".panel")[panelIdx];
  if (!panel) return;

  // Remove existing legend
  var existing = panel.querySelector(".color-legend");
  if (existing) existing.remove();

  if (!info) return;

  var div = document.createElement("div");
  div.className = "color-legend";
  div.innerHTML =
    '<div class="cl-title">' + info.label + ' (' + info.units + ')</div>' +
    '<div class="cl-bar" style="background:' + _cmapToCSS(info.cmap) + '"></div>' +
    '<div class="cl-labels"><span>' + _formatValue(info.vmin) + '</span><span>' + _formatValue(info.vmax) + '</span></div>';
  panel.appendChild(div);
}

async function loadSingleFieldImage(idx, fieldName) {
  var map = maps[idx];

  // Si es "none", quitar overlay y leyenda
  if (fieldName === "none") {
    if (fieldOverlays[idx]) { map.removeLayer(fieldOverlays[idx]); fieldOverlays[idx] = null; }
    updateColorLegend(idx, null);
    return;
  }

  var vp = _getViewportParams(map);
  var timestamp = Date.now();
  var url = "/api/fields/" + fieldName + "/image?" + vp + "&t=" + timestamp;
  if (fieldOverlays[idx]) map.removeLayer(fieldOverlays[idx]);
  var overlay = L.imageOverlay(url, dataBounds, {
    opacity: 0.65, interactive: false, zIndex: 100,
  });
  overlay.addTo(map);
  fieldOverlays[idx] = overlay;

  // Fetch colorbar info
  try {
    var cbResp = await fetch("/api/fields/" + fieldName + "/colorbar?" + vp);
    if (cbResp.ok) {
      var cbInfo = await cbResp.json();
      updateColorLegend(idx, cbInfo);
    }
  } catch (e) { /* ignore */ }
}

async function loadPrecipOverlay() {
  if (!dataLoaded || !dataBounds) return;
  // Remove existing
  for (var i = 0; i < maps.length; i++) {
    if (precipOverlays[i]) { maps[i].removeLayer(precipOverlays[i]); precipOverlays[i] = null; }
  }
  if (!document.getElementById("precip-check").checked) return;

  // Verificar si hay datos de precipitacion
  try {
    var statusResp = await fetch("/api/precipitation/status");
    var statusData = await statusResp.json();
    if (!statusData.available) {
      setStatus("Precip: " + statusData.reason);
      document.getElementById("precip-check").checked = false;
      return;
    }
  } catch (e) { /* continuar igualmente */ }

  var timestamp = Date.now();
  var url = "/api/precipitation/image?t=" + timestamp;
  for (var i = 0; i < maps.length; i++) {
    var overlay = L.imageOverlay(url, dataBounds, {
      opacity: 0.7, interactive: false, zIndex: 150,
    });
    overlay.addTo(maps[i]);
    precipOverlays[i] = overlay;
  }
  setStatus("Precipitacion activada");
}

// --- Wind arrows canvas layer ---
// Dibuja flechas de viento directamente en canvas de Leaflet (no PNG).
// Se adaptan al zoom y siempre se ven nitidas.

var _windDataCache = {};  // cache por nivel: { 850: {lat,lon,u,v,color,alpha}, ... }

L.WindArrowsLayer = L.Layer.extend({
  initialize: function(data, options) {
    this._data = data;  // {lat[], lon[], u[], v[], color, alpha}
    L.Util.setOptions(this, options);
  },

  onAdd: function(map) {
    this._map = map;
    this._canvas = L.DomUtil.create("canvas", "wind-arrows-canvas");
    this._canvas.style.position = "absolute";
    this._canvas.style.pointerEvents = "none";
    this._canvas.style.zIndex = "200";
    map.getPane("overlayPane").appendChild(this._canvas);
    map.on("moveend zoomend resize", this._redraw, this);
    this._redraw();
  },

  onRemove: function(map) {
    map.off("moveend zoomend resize", this._redraw, this);
    L.DomUtil.remove(this._canvas);
  },

  _redraw: function() {
    var map = this._map;
    var size = map.getSize();
    var canvas = this._canvas;
    canvas.width = size.x;
    canvas.height = size.y;
    var topLeft = map.containerPointToLayerPoint([0, 0]);
    L.DomUtil.setPosition(canvas, topLeft);

    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, size.x, size.y);

    var d = this._data;
    if (!d || !d.lat || d.lat.length === 0) return;

    var bounds = map.getBounds();
    var zoom = map.getZoom();

    // Tamano de flecha en pixeles, adaptado al zoom
    var arrowLen = Math.max(8, Math.min(22, 4 + zoom * 2.5));
    var headLen = arrowLen * 0.35;
    var headHalf = headLen * 0.45;
    var lineWidth = Math.max(1, arrowLen / 12);

    ctx.strokeStyle = d.color || "#555555";
    ctx.fillStyle = d.color || "#555555";
    ctx.globalAlpha = d.alpha !== undefined ? d.alpha : 1.0;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = "round";

    for (var i = 0; i < d.lat.length; i++) {
      var lat = d.lat[i], lon = d.lon[i];

      // Solo dibujar si esta en el viewport
      if (lat < bounds.getSouth() || lat > bounds.getNorth()) continue;
      if (lon < bounds.getWest() || lon > bounds.getEast()) continue;

      var pt = map.latLngToContainerPoint([lat, lon]);
      var u = d.u[i], v = d.v[i];
      var speed = Math.sqrt(u * u + v * v);
      if (speed < 0.5) continue;  // no dibujar calma

      // Angulo: u=este, v=norte
      var angle = Math.atan2(-v, u);  // canvas Y invertido

      // Escalar longitud por velocidad (normalizado a ~40kt max)
      var lenScale = Math.min(speed / 40, 1.5);
      var len = arrowLen * lenScale;

      var dx = Math.cos(angle) * len;
      var dy = Math.sin(angle) * len;

      var x0 = pt.x - dx * 0.5;
      var y0 = pt.y - dy * 0.5;
      var x1 = pt.x + dx * 0.5;
      var y1 = pt.y + dy * 0.5;

      // Linea del cuerpo
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();

      // Punta de flecha
      var ha = Math.atan2(dy, dx);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(
        x1 - headLen * Math.cos(ha - 0.45),
        y1 - headLen * Math.sin(ha - 0.45)
      );
      ctx.lineTo(
        x1 - headLen * Math.cos(ha + 0.45),
        y1 - headLen * Math.sin(ha + 0.45)
      );
      ctx.closePath();
      ctx.fill();
    }
  },
});

function loadWindOverlays() {
  if (!dataLoaded) return;

  // Eliminar layers existentes
  for (var i = 0; i < maps.length; i++) {
    if (windLayers[i]) {
      windLayers[i].forEach(function(layer) { maps[i].removeLayer(layer); });
      windLayers[i] = null;
    }
  }

  var levels = [];
  if (document.getElementById("wind-850-check").checked) levels.push(850);
  if (document.getElementById("wind-700-check").checked) levels.push(700);
  if (levels.length === 0) return;

  // Cargar datos JSON para cada nivel y dibujar en canvas
  levels.forEach(function(level) {
    // Usar cache si existe
    if (_windDataCache[level]) {
      _addWindLayersForLevel(level, _windDataCache[level]);
      return;
    }

    fetch("/api/wind_vectors/" + level + "/data")
      .then(function(r) { return r.json(); })
      .then(function(data) {
        _windDataCache[level] = data;
        _addWindLayersForLevel(level, data);
      })
      .catch(function(e) {
        console.warn("Error cargando viento " + level + ":", e);
      });
  });
}

function _addWindLayersForLevel(level, data) {
  for (var i = 0; i < maps.length; i++) {
    var layer = new L.WindArrowsLayer(data);
    layer.addTo(maps[i]);
    if (!windLayers[i]) windLayers[i] = [];
    windLayers[i].push(layer);
  }
}

var _syncing = false;
function syncMaps(sourceIdx) {
  if (_syncing) return;
  _syncing = true;
  var center = maps[sourceIdx].getCenter();
  var zoom = maps[sourceIdx].getZoom();
  maps.forEach(function(m, i) {
    if (i !== sourceIdx) m.setView(center, zoom, { animate: false });
  });
  setTimeout(function() { _syncing = false; }, 150);
}

// ==========================================================================
// Load data
// ==========================================================================
async function loadData() {
  var dateStr = document.getElementById("date-input").value.trim() || null;
  var step = parseInt(document.getElementById("step-select").value);

  showLoading();
  setStatus("Descargando datos ECMWF...");

  try {
    var resp = await fetch("/api/load", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ date: dateStr, step: step }),
    });
    if (!resp.ok) {
      var err = await resp.json();
      throw new Error(err.detail || "Error cargando datos");
    }
    var data = await resp.json();

    var boundsResp = await fetch("/api/bounds");
    var boundsData = await boundsResp.json();
    var db = boundsData.data_bounds;
    dataBounds = [[db.south, db.west], [db.north, db.east]];

    if (boundsData.fields) {
      availableFields = boundsData.fields;
      updatePanelDropdowns();
    }

    setStatus("Generando capas...");

    await Promise.all([
      loadFieldImages(),
      loadIsobars(),
      loadCenters(),
    ]);

    dataLoaded = true;
    _windDataCache = {};  // invalidar cache de viento al recargar datos
    setButtonsEnabled(true);

    masterFronts = { type: "FeatureCollection", features: [] };
    renderFrontsOnAllPanels();

    var dateInfo = boundsData.date_info || "";
    setStatus("Datos cargados: " + data.n_centers + " centros. " + dateInfo);
  } catch (e) {
    setStatus("Error: " + e.message);
    console.error(e);
  } finally {
    hideLoading();
  }
}

function updatePanelDropdowns() {
  if (!availableFields) return;
  var fieldKeys = Object.keys(availableFields);

  document.querySelectorAll(".panel-field-select").forEach(function(sel) {
    var currentVal = sel.value;
    var idx = parseInt(sel.dataset.panelIdx);
    sel.innerHTML = "";
    var noneOpt = document.createElement("option");
    noneOpt.value = "none";
    noneOpt.textContent = "Sin fondo";
    sel.appendChild(noneOpt);
    fieldKeys.forEach(function(key) {
      var opt = document.createElement("option");
      opt.value = key;
      opt.textContent = availableFields[key];
      sel.appendChild(opt);
    });
    if (fieldKeys.includes(currentVal)) {
      sel.value = currentVal;
    } else {
      var def = DEFAULT_FIELDS[idx % DEFAULT_FIELDS.length];
      sel.value = fieldKeys.includes(def) ? def : fieldKeys[0];
    }
  });
}

// ==========================================================================
// Field images
// ==========================================================================
async function loadFieldImages() {
  var selectors = document.querySelectorAll(".panel-field-select");
  var promises = [];

  for (var i = 0; i < maps.length; i++) {
    var fieldName = selectors[i] ? selectors[i].value : DEFAULT_FIELDS[i % DEFAULT_FIELDS.length];
    promises.push(loadSingleFieldImage(i, fieldName));
  }
  await Promise.all(promises);
}

var _refreshFieldsTimeout = null;
function refreshFieldsForViewport() {
  if (_refreshFieldsTimeout) clearTimeout(_refreshFieldsTimeout);
  _refreshFieldsTimeout = setTimeout(function() {
    loadFieldImages();
  }, 400);
}

// ==========================================================================
// Isobars
// ==========================================================================
async function loadIsobars() {
  var resp = await fetch("/api/isobars");
  var geojson = await resp.json();

  maps.forEach(function(map, i) {
    if (isobarLayers[i]) map.removeLayer(isobarLayers[i]);
    isobarLayers[i] = L.geoJSON(geojson, {
      style: function(feature) {
        return {
          color: "#444",
          weight: feature.properties.is_master ? 1.4 : 0.5,
          opacity: feature.properties.is_master ? 0.7 : 0.4,
          interactive: false,
        };
      },
    }).addTo(map);
  });
}

// ==========================================================================
// Pressure centers
// ==========================================================================
async function loadCenters() {
  var resp = await fetch("/api/centers");
  var centers = await resp.json();

  maps.forEach(function(map, i) {
    if (centerLayers[i]) map.removeLayer(centerLayers[i]);

    var layer = L.layerGroup();
    centers.forEach(function(c) {
      var label = c.primary ? c.label.toUpperCase() : c.label.toLowerCase();
      var color = c.type === "H" ? "#0044CC" : "#CC0000";
      var size = c.primary ? 16 : 12;
      var nameHtml = c.name ? '<br><span style="font-size:9px;font-style:italic">' + c.name + '</span>' : "";

      var icon = L.divIcon({
        className: "",
        html: '<div style="text-align:center;color:' + color + ';font-weight:bold;' +
          'font-size:' + size + 'px;text-shadow:0 0 3px white,0 0 3px white,0 0 5px white;' +
          'line-height:1.1;pointer-events:auto;cursor:pointer;">' +
          label + nameHtml + '<br>' +
          '<span style="font-size:' + (size - 4) + 'px">' + Math.round(c.value) + '</span>' +
          '</div>',
        iconSize: [50, 36],
        iconAnchor: [25, 18],
      });

      var marker = L.marker([c.lat, c.lon], { icon: icon, interactive: true });
      if (c.type === "L") {
        marker.on("click", function() { generateFromCenter(c.id, c.value); });
      }
      marker.addTo(layer);
    });
    layer.addTo(map);
    centerLayers[i] = layer;
  });
}

// ==========================================================================
// Actions
// ==========================================================================
async function detectFronts() {
  showLoading();
  setStatus("Detectando frentes...");
  try {
    var resp = await fetch("/api/fronts/detect");
    var geojson = await resp.json();
    masterFronts = geojson;
    renderFrontsOnAllPanels();
    var n = geojson.features ? geojson.features.length : 0;
    setStatus(n + " frentes detectados. Click en un frente para eliminarlo.");
  } catch (e) {
    setStatus("Error detectando: " + e.message);
  } finally {
    hideLoading();
  }
}

async function saveFronts() {
  try {
    var resp = await fetch("/api/fronts", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterFronts),
    });
    var data = await resp.json();
    setStatus("Frentes guardados (" + data.n_fronts + ")");
  } catch (e) {
    setStatus("Error guardando: " + e.message);
  }
}

async function generateFromCenter(centerId, value) {
  showLoading();
  setStatus("Generando frentes desde " + centerId + " (" + Math.round(value) + " hPa)...");
  try {
    var resp = await fetch("/api/fronts/generate/" + centerId, { method: "POST" });
    var geojson = await resp.json();
    masterFronts = geojson;
    renderFrontsOnAllPanels();
    var n = geojson.features ? geojson.features.length : 0;
    setStatus(n + " frentes totales");
  } catch (e) {
    setStatus("Error generando: " + e.message);
  } finally {
    hideLoading();
  }
}

function flipAllFronts() {
  (masterFronts.features || []).forEach(function(f) {
    if (f.properties) {
      f.properties.flip = !f.properties.flip;
      f.properties.flip_symbols = f.properties.flip;
    }
  });
  renderFrontsOnAllPanels();
  setStatus("Simbolos invertidos");
}

function _getOverlayParams() {
  var params = "";
  if (document.getElementById("precip-check").checked) params += "&precip=true";
  if (document.getElementById("wind-850-check").checked) params += "&wind_levels=850";
  if (document.getElementById("wind-700-check").checked) params += "&wind_levels=700";
  return params;
}

async function exportMap(clean) {
  var fieldName = "none";
  if (!clean) {
    var sel = document.querySelector('.panel-field-select[data-panel-idx="0"]');
    if (sel) fieldName = sel.value;
  }
  // Guardar frentes al backend antes de exportar (para preservar flip y ediciones)
  try {
    await fetch("/api/fronts", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterFronts),
    });
  } catch (e) {
    console.warn("No se pudieron guardar frentes antes de exportar:", e);
  }
  var url = "/api/export?field=" + encodeURIComponent(fieldName) + "&clean=" + (clean ? "true" : "false") + _getOverlayParams();
  setStatus("Exportando mapa Lambert" + (clean ? " (limpio)" : " (" + fieldName + ")") + "...");
  window.open(url, "_blank");
}

async function exportMosaic() {
  // Recopilar campos de cada panel visible
  var fields = [];
  document.querySelectorAll(".panel-field-select").forEach(function(sel) {
    fields.push(sel.value || "none");
  });
  if (fields.length === 0) { setStatus("No hay paneles visibles"); return; }

  // Guardar frentes al backend
  try {
    await fetch("/api/fronts", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(masterFronts),
    });
  } catch (e) {
    console.warn("No se pudieron guardar frentes antes de exportar:", e);
  }

  var layout = parseLayout();
  var params = "cols=" + layout.cols + "&rows=" + layout.rows;
  fields.forEach(function(f) { params += "&fields=" + encodeURIComponent(f); });
  params += _getOverlayParams();
  var url = "/api/export/mosaic?" + params;
  setStatus("Exportando mosaico " + layout.cols + "x" + layout.rows + " en Lambert...");
  window.open(url, "_blank");
}

// ==========================================================================
// Edit mode: select front + drag vertices
// ==========================================================================

function clearEditSelection() {
  // Remove vertex markers from panel 0
  vertexMarkers.forEach(function(m) { m.remove(); });
  vertexMarkers = [];
  // Remove highlight polylines from all panels
  editHighlights.forEach(function(hl) { hl.remove(); });
  editHighlights = [];
  selectedFeature = null;
}

function selectFrontForEdit(feature) {
  clearEditSelection();
  selectedFeature = feature;
  var coords = feature.geometry.coordinates;
  var latlngs = coords.map(function(c) { return [c[1], c[0]]; });

  // Highlight polyline on all panels
  maps.forEach(function(map) {
    if (!map) return;
    var hl = L.polyline(latlngs, {
      color: "#FFD700", weight: 5, opacity: 0.7, interactive: false,
    }).addTo(map);
    editHighlights.push(hl);
  });

  // Draggable vertex markers on panel 0 only (using vertexEdit pane for z-index)
  var map0 = maps[0];
  if (!map0) return;

  var vertexIcon = L.divIcon({
    className: "vertex-marker",
    iconSize: [14, 14],
    iconAnchor: [7, 7],
  });

  coords.forEach(function(coord, idx) {
    var marker = L.marker([coord[1], coord[0]], {
      icon: vertexIcon,
      draggable: true,
      pane: "vertexEdit",
    }).addTo(map0);

    // Prevent map click (deselect) when interacting with vertex markers
    marker.on("mousedown", function(e) { L.DomEvent.stopPropagation(e); });

    marker.on("drag", function(e) {
      var pos = e.target.getLatLng();
      // Update GeoJSON coordinates
      feature.geometry.coordinates[idx] = [pos.lng, pos.lat];
      // Update highlight polylines in real time
      var newLatLngs = feature.geometry.coordinates.map(function(c) {
        return [c[1], c[0]];
      });
      editHighlights.forEach(function(hl) { hl.setLatLngs(newLatLngs); });
    });

    marker.on("dragend", function() {
      // Re-render WMO symbols on all panels with new geometry
      renderFrontsOnAllPanels();
      // Re-select to refresh highlights and vertex positions
      selectFrontForEdit(feature);
    });

    vertexMarkers.push(marker);
  });

  var ft = feature.properties.front_type || "?";
  setStatus("Editando frente " + ft + " (" + coords.length + " vertices). Arrastra vertices para deformar.");
}

function toggleEditMode() {
  editMode = !editMode;
  var btn = document.getElementById("btn-edit-mode");
  if (editMode) {
    // Desactivar delete mode si estaba activo
    if (deleteMode) {
      deleteMode = false;
      document.getElementById("btn-delete-mode").classList.remove("active-mode");
    }
    btn.classList.add("active-mode");
    setStatus("Modo editar activo: click en un frente para seleccionarlo");
  } else {
    btn.classList.remove("active-mode");
    clearEditSelection();
    setStatus("Modo editar desactivado");
  }
}

function toggleDeleteMode() {
  deleteMode = !deleteMode;
  var btn = document.getElementById("btn-delete-mode");
  if (deleteMode) {
    // Desactivar edit mode si estaba activo
    if (editMode) {
      editMode = false;
      clearEditSelection();
      document.getElementById("btn-edit-mode").classList.remove("active-mode");
    }
    btn.classList.add("active-mode");
    setStatus("Modo borrar activo: click en un frente para eliminarlo");
  } else {
    btn.classList.remove("active-mode");
    setStatus("Modo borrar desactivado");
  }
}

// ==========================================================================
// Event bindings
// ==========================================================================
document.getElementById("btn-load").addEventListener("click", loadData);
document.getElementById("btn-detect").addEventListener("click", detectFronts);
document.getElementById("btn-save").addEventListener("click", saveFronts);

// Export dropdown toggle
document.getElementById("btn-export-toggle").addEventListener("click", function(e) {
  e.stopPropagation();
  var menu = document.getElementById("export-menu");
  menu.classList.toggle("open");
});
document.addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
});
document.getElementById("btn-export").addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  exportMap(false);
});
document.getElementById("btn-export-clean").addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  exportMap(true);
});
document.getElementById("btn-export-mosaic").addEventListener("click", function() {
  document.getElementById("export-menu").classList.remove("open");
  exportMosaic();
});

document.getElementById("precip-check").addEventListener("change", loadPrecipOverlay);
document.getElementById("wind-850-check").addEventListener("change", loadWindOverlays);
document.getElementById("wind-700-check").addEventListener("change", loadWindOverlays);

document.getElementById("btn-flip").addEventListener("click", flipAllFronts);
document.getElementById("btn-edit-mode").addEventListener("click", toggleEditMode);
document.getElementById("btn-delete-mode").addEventListener("click", toggleDeleteMode);

// Escape key: deselect front in edit mode
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape" && editMode && selectedFeature) {
    clearEditSelection();
    setStatus("Frente deseleccionado");
  }
});

document.getElementById("layout-select").addEventListener("change", function() {
  var layout = parseLayout();
  rebuildMosaic(layout.cols, layout.rows);
});

document.getElementById("front-type-select").addEventListener("change", updateAllDrawOptions);

// ==========================================================================
// Init
// ==========================================================================
(async function init() {
  await loadCoastlines();
  var layout = parseLayout();
  rebuildMosaic(layout.cols, layout.rows);
  document.getElementById("front-type-swatch").style.background = getSelectedFrontColor();
  setStatus("Listo. Introduzca fecha y pulse 'Cargar datos'.");
})();
</script>

</body>
</html>
